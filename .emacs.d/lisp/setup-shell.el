;;; setup-shell.el --- Shell configuration module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

;; Author: Nicolas CHAPON
;; Keywords: Emacs configuration
;; Homepage:

;;; Commentary:
;; Emacs config file.
;; This file was automatically generated by `org-babel-tangle'.
;; Do not change this file.  Main config is located in Readme.org at `user-emacs-directory'

;;; Code:

(use-package vterm
  :commands vterm
  :unless is-windows
  :custom
  (vterm-disable-bold-font t)
  (vterm-disable-inverse-video nil)
  (vterm-disable-underline nil)
  (vterm-kill-buffer-on-exit t)
  (vterm-max-scrollback 9999)
  (vterm-shell "/bin/zsh")
  (vterm-term-environment-variable "xterm-256color"))

(use-package vterm-toggle
  :custom
  ;; Show Vterm Buffer in bottom side
  (vterm-toggle-fullscreen-p nil)
  :unless is-windows
  :config
  (add-to-list 'display-buffer-alist
     '("\*vterm\*"
       (display-buffer-in-side-window)
       (window-height . 0.3)
       (side . bottom)
       (slot . 0)))

  :bind
  ("C-c s" . vterm-toggle)
  (:map vterm-mode-map
        ("C-<return>" . vterm-toggle-insert-cd)
        ("C-S-n" . vterm-toggle-forward)
        ("C-S-p" . vterm-toggle-backward)
        ))

(defun nc/map-line-to-status-char (line)
  (cond ((string-match "^?\\? " line) "?")))

(defun nc/get-git-status-prompt ()
  (let ((status-lines (cdr (process-lines "git" "status" "--porcelain" "-b"))))
    (seq-uniq (seq-filter 'identity (mapcar 'nc/map-line-to-status-char status-lines)))))

(defun nc/get-prompt-path ()
  (let* ((current-path (eshell/pwd))
         (git-output (shell-command-to-string "git rev-parse --show-toplevel"))
         (has-path (not (string-match "^fatal" git-output))))
    (if (not has-path)
      (abbreviate-file-name current-path)
      (string-remove-prefix (file-name-directory git-output) current-path))))

;; This prompt function mostly replicates my custom zsh prompt setup
;; that is powered by github.com/denysdovhan/spaceship-prompt.
(defun nc/eshell-prompt ()
  (let ((current-branch (magit-get-current-branch))
        )
    (concat
     "\n"
     (propertize (system-name) 'face `(:foreground "#62aeed"))
     (propertize " > " 'face `(:foreground "white"))
     (propertize (nc/get-prompt-path) 'face `(:foreground "#82cfd3"))
     (when current-branch
       (concat
        (propertize " • " 'face `(:foreground "white"))
        (propertize (concat " " current-branch) 'face `(:foreground "#c475f0"))))

     (propertize " • " 'face `(:foreground "white"))
     (propertize (format-time-string "%I:%M:%S %p") 'face `(:foreground "#5a5b7f"))
     (if (= (user-uid) 0)
         (propertize "\n#" 'face `(:foreground "red2"))
       (propertize "\nλ" 'face `(:foreground "#aece4a")))
     (propertize " " 'face `(:foreground "white")))))

(defun nc/eshell-configure ()

  (use-package xterm-color)

  (push 'eshell-tramp eshell-modules-list)
  (push 'xterm-color-filter eshell-preoutput-filter-functions)
  (delq 'eshell-handle-ansi-color eshell-output-filter-functions)

  ;; Save command history when commands are entered
  (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

  (add-hook 'eshell-before-prompt-hook
            (lambda ()
              (setq xterm-color-preserve-properties t)))

  ;; Truncate buffer for performance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  ;; We want to use xterm-256color when running interactive commands
  ;; in eshell but not during other times when we might be launching
  ;; a shell command to gather its output.
  (add-hook 'eshell-pre-command-hook
            (lambda () (setenv "TERM" "xterm-256color")))
  (add-hook 'eshell-post-command-hook
            (lambda () (setenv "TERM" "dumb")))

  ;; Use completion-at-point to provide completions in eshell
  (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)
  (define-key eshell-mode-map (kbd "C-r") 'consult-history)

  ;; Visual Commands
  (require 'em-term)
  (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                                 "ncftp" "pine" "tin" "trn" "elm" "htop" "node" "npm")
        eshell-visual-subcommands '(("git" "log" "diff" "show")))

  ;; Initialize the shell history
  (eshell-hist-initialize)

  (setenv "PAGER" "cat")

  (setq eshell-prompt-function      'nc/eshell-prompt
        eshell-prompt-regexp        "^λ "
        eshell-history-size         10000
        eshell-buffer-maximum-lines 10000
        eshell-hist-ignoredups t
        eshell-highlight-prompt t
        eshell-scroll-to-bottom-on-input t
        eshell-prefer-lisp-functions nil))

(use-package eshell
  :after esh-mode
  :hook (eshell-first-time-mode . nc/eshell-configure)

  :config

  (defun nc/eshell-clear-buffer ()
    "Clear terminal"
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))


  (defun nc/eshell-quit-or-delete-char (arg)
    (interactive "p")
    (if (and (eolp) (looking-back eshell-prompt-regexp))
        (progn
          (eshell-life-is-too-much) ; Why not? (eshell/exit)
          (ignore-errors
            (delete-window)))
      (delete-forward-char arg)))

  :bind
  (:map eshell-mode-map
        ("C-d" . nc/eshell-quit-or-delete-char)
        ("C-l" . nc/eshell-clear-buffer))

  )

(use-package eshell-toggle
  :custom
  (eshell-toggle-size-fraction 3)
  (eshell-toggle-use-projectile-root t)
  (eshell-toggle-run-command nil)
  :bind ("C-c e" . eshell-toggle))

(use-package dwim-shell-command
  :bind (([remap shell-command] . dwim-shell-command)
         :map dired-mode-map
         ([remap dired-do-async-shell-command] . dwim-shell-command)
         ([remap dired-do-shell-command] . dwim-shell-command)
         ([remap dired-smart-shell-command] . dwim-shell-command))
  :config
  (defun nc/dwim-shell-command-plantuml-to-png ()
    "Render plantuml file into PNG"
    (interactive)
    (dwim-shell-command-on-marked-files
     "Render to puml"
     "plantuml.bat '<<f>>'"
     :extensions "puml"
     :utils "java"
     :on-completion
     (lambda (buffer _process)
       (with-current-buffer buffer
         (save-excursion
           (goto-char 0)
           (when (re-search-forward "output='\\(.*\\)'" nil t)
               (find-file-other-window (match-string-no-properties 1))
               (kill-buffer buffer)
             )))))
    )
  )

(provide 'setup-shell)
;;; setup-shell.el ends here
