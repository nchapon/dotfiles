#+title: Emacs configuration with Org Mode
#+author: Nicolas Chapon
#+email: nchapon@gmail.com
#+startup: noinlineimages
#+property: header-args :results silent

* About this document
This is a GNU Emacs configuration file, written as an Org document.
As a result =init.el= and =early-init.el= files are created, located in the same directory as this file, as well as some other files across the system.
You can review which files are created by searching for =:tangle= entries in this document.
Both =init.el= and =early-init.el= and all created files in =./lisp= directory are in read only mode by default, and only this file is meant for editing, and the changes are automatically tangled on save.

Code block below is included in each generatde file :

#+name: nc-header
#+begin_src emacs-lisp
  ;; Author: Nicolas CHAPON
  ;; Keywords: Emacs configuration
  ;; Homepage:

  ;;; Commentary:
  ;; Emacs config file.
  ;; This file was automatically generated by `org-babel-tangle'.
  ;; Do not change this file.  Main config is located in Readme.org at `user-emacs-directory'

  ;;; Code:
#+end_src
** Inspirations
Some parts at this configuration file are copied / adapted from some useful configuration :
- https://www.lucacambiaghi.com/vanilla-emacs/readme.html
- [[https://github.com/MatthewZMD/.emacs.d]]
- https://gitlab.imt-atlantique.fr/jnbazin/emacs-config/-/blob/master/emacs-init.org (french)

* Early Init

Emacs 27 introduced new initialization file called =early-init.el=, which is executed before =init.el=.
It is meant to configure package initialization and early graphical interface tweaks, before actually drawing a window.

#+begin_src emacs-lisp :tangle early-init.el :noweb yes
  ;;; early-init.el --- Early initialization -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src

** Garbage Collection and Performance
One of the main reasons why Emacs startup time is big is that the garbage collection is invoked a lot, causing the increase of the startup time.
This can be migrated by setting high GC threshold and restoring it back in =after-init-hook=.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar nc--gc-cons-threshold gc-cons-threshold)
  (defvar nc--gc-cons-percentage gc-cons-percentage)
  (defvar nc--file-name-handler-alist file-name-handler-alist)

  (setq-default gc-cons-threshold 402653184
                gc-cons-percentage 0.6
                file-name-handler-alist nil)

  (defun nc/restore-defaults-after-init ()
    "Restore default values after initialization."
    (setq-default gc-cons-threshold nc--gc-cons-threshold
                  gc-cons-percentage nc--gc-cons-percentage
                  file-name-handler-alist nc--file-name-handler-alist))

  (add-hook 'after-init-hook #'nc/restore-defaults-after-init)

  (setq read-process-output-max (* 1024 1024 4) ; 4mb
        inhibit-compacting-font-caches t
        message-log-max 16384)
#+end_src

** Straight
Straight is an alternative way to manage package installations.
It can install packages from Git repositories listed on ELPA, MELPA, and directly from Git URLs.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar straight-process-buffer)
  (setq-default straight-process-buffer " *straight-process*")

  (defvar straight-build-dir)
  (setq straight-build-dir (format "build-%s" emacs-version))

  (defvar bootstrap-version)
  (let ((bootstrap-file
     (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
       'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** Early =package.el= settings
=package.el= initialization is expensive, thus should be disabled before loading main init file:

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
#+end_src

** Loading of elisp files
Prefer loading newer files to the byte-compiled ones that have older time-stamp when running non-interactively to prevent the use of stale byte-code.
Saves us a little IO time to skip the mtime checks on every =*.elc= file.

#+begin_src emacs-lisp :tangle early-init.el
  (setq load-prefer-newer noninteractive)
#+end_src

** Provide early-init
This concludes the =early-init.el= file.

#+begin_src emacs-lisp :tangle early-init.el
  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src

* Init configuration
:properties:
:header-args+: :tangle "./init.el"
:end:
Main GNU Emacs init file =init.el=.

#+begin_src emacs-lisp :noweb yes
  ;;; init.el --- Emacs main configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src


** Loading =early-init.el= in Emacs 26 and earlier
When using pre Emacs 27 =eraly-init.el= must be loaded manually before anything from =init.el=.

#+begin_src emacs-lisp
  (unless (featurep 'early-init)
    (load (expand-file-name "early-init" user-emacs-directory)))
#+end_src

** Package Management
*** =use-package=
A macro for managing installed packages, and encapsulating their configurations.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (defvar straight-use-package-by-default)
  (setq straight-use-package-by-default t)
  (require 'use-package)
#+end_src
*** Diminish
Remove minor modes from mode line
#+begin_src emacs-lisp
(use-package diminish)
#+end_src

** Exec Path From Shell

[[https://github.com/purcell/exec-path-from-shell][Exec Path From Shell]] A GNU Emacs library to ensure environment variables inside Emacs look the same as in the user's shell.

This happens a lot on OS X, where an Emacs instance started from the GUI inherits a default set of environment variables.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac ns x))
      (progn
        (exec-path-from-shell-initialize)
        ;; (exec-path-from-shell-copy-env "GOPATH")
        ;;(exec-path-from-shell-copy-env "JAVA_HOME")
        (exec-path-from-shell-copy-env "XDG_CONFIG_HOME")
        )))
#+end_src

** No Littering
:PROPERTIES:
:ID:       3f627579-3efc-4c40-9dbe-558de5359f8e
:END:

Help keeping =~/.emacs.d= clean.
[[https://github.com/emacscollective/no-littering][https://github.com/emacscollective/no-littering]]

#+begin_src emacs-lisp
(use-package no-littering)
#+end_src
** Setup modules

Add setup modules and conclude the =init.el= file.

#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

  (require 'setup-prefs)
  (require 'setup-ui)
  (require 'setup-keys)
  (require 'setup-windows)
  (require 'setup-core)
  (require 'setup-completion)
  (require 'setup-org)
  (require 'setup-programming)
  (require 'setup-shell)
  (require 'setup-functions)

  (provide 'init)
  ;;; init.el ends here
#+end_src

* Global Preferences
:properties:
:header-args+: :tangle "./lisp/setup-prefs.el"
:end:

Global preferences module automatically tangled in =./lisp/setup-prefs.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-prefs.el --- Global Preferences module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src

** Personal Information
 #+begin_src emacs-lisp
 (setq user-full-name "Nicolas Chapon"
         user-mail-address "nchapon@gmail.com")
 #+end_src

** Define constants

#+begin_src emacs-lisp
  (defconst is-mac (equal system-type 'darwin))
  (defconst is-linux (equal system-type 'gnu/linux))
  (defconst is-windows (equal system-type 'windows-nt))
  (defconst has-gui (display-graphic-p))
#+end_src
** Customization File
To avoid overloading the GNU Emacs custormization =init.el= file made by the
user with the UI, I add the generated code in a separate file.

#+begin_src emacs-lisp
  (setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file t))
#+end_src
** Better Defaults
Small configs for better emacs experience...

#+begin_src emacs-lisp
  (setq initial-major-mode 'lisp-interaction-mode
        redisplay-dont-pause t
        column-number-mode t
        echo-keystrokes 0.02
        fill-column 80
        transient-mark-mode t
        shift-select-mode nil
        require-final-newline t
        truncate-partial-width-windows nil
        delete-by-moving-to-trash t
        confirm-nonexistent-file-or-buffer nil
        query-replace-highlight t
        ;; do not create lock files
        create-lockfiles nil
        ring-bell-function 'ignore
        sentence-end-double-space nil)
 #+end_src
*** Tab Defaults

#+begin_src emacs-lisp
  (setq-default tab-width 4)
#+end_src

*** Transparently open compressed files
 #+begin_src emacs-lisp
 (auto-compression-mode t)
 #+end_src

*** Answering just 'y' or 'n'

 #+begin_src emacs-lisp
 (defalias 'yes-or-no-p 'y-or-n-p)
 #+end_src

*** Indentation & Tabs

 Always spaces with width of 4
 #+begin_src emacs-lisp
 (setq-default indent-tabs-mode nil)
 (setq-default tab-width 4)
 #+end_src
*** TODO Indent new line if necessary
Remove to bindings
#+begin_src emacs-lisp
 (define-key global-map (kbd "RET") 'newline-and-indent)
 #+end_src
*** Backup Files
Backup files in  [[id:3f627579-3efc-4c40-9dbe-558de5359f8e][no Littering]] folder
#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/var/backups/")))
#+end_src
** UTF-8 Encoding

 Set all coding systems to utf-8
 #+begin_src emacs-lisp
 (prefer-coding-system 'utf-8-unix)
 (set-clipboard-coding-system 'utf-8-unix)
 (set-default-coding-systems 'utf-8-unix)
 (set-keyboard-coding-system 'utf-8-unix)
 (set-language-environment 'utf-8)
 (set-selection-coding-system 'utf-8-unix)
 (set-terminal-coding-system 'utf-8-unix)
 (setq locale-coding-system 'utf-8-unix)
 (setq coding-system-for-write 'utf-8-unix)
 (setq default-buffer-file-coding-system 'utf-8-unix)
 (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
 (setq file-name-coding-system  'utf-8)
 #+end_src
** French Calendar & Holydays
 French Calendar & Holidays
 #+begin_src emacs-lisp
   (setq calendar-week-start-day 1
         calendar-day-name-array ["Dimanche" "Lundi" "Mardi" "Mercredi"
                                  "Jeudi" "Vendredi" "Samedi"]
         calendar-month-name-array ["Janvier" "Fevrier" "Mars" "Avril" "Mai"
                                    "Juin" "Juillet" "Aout" "Septembre"
                                    "Octobre" "Novembre" "Decembre"])
 #+end_src

 #+begin_src emacs-lisp
   (defvar french-holiday
     '((holiday-fixed 1 1 "Jour de l'an")
       (holiday-fixed 5 1 "Fête du travail")
       (holiday-fixed 5 8 "Victoire 45")
       (holiday-fixed 7 14 "Fête nationale")
       (holiday-fixed 8 15 "Assomption")
       (holiday-fixed 11 1 "Toussaint")
       (holiday-fixed 11 11 "Armistice 18")
       (holiday-fixed 12 25 "Noël")
       (holiday-easter-etc 1 "Lundi de Pâques")
       (holiday-easter-etc 39 "Ascension")
       (holiday-easter-etc 50 "Lundi de Pentecôte")))

   (setq calendar-date-style 'european
         calendar-holidays french-holiday
         calendar-mark-holidays-flag t
         calendar-mark-diary-entries-flag t)

 #+end_src


** MacOS
Some custom preferences dedicated to MacOS
- keys for apple keyboard
- use the right ~⌥~ key to write symbols ={[]}=. The left ~⌥~ key can be used as the Meta
- GPG
- ...

 #+begin_src emacs-lisp
   (when is-mac
     ;; Keys for Appel keyboard
     (setq mac-command-modifier 'meta)    ; make cmd key do Meta
     (setq mac-option-modifier 'super)    ; make opt key do Super
     (setq mac-control-modifier 'control) ; make Control key do Control
     (setq ns-function-modifier 'hyper)   ; make Fn key do Hyper

     (setq trash-directory "~/.Trash")    ; Trash Directory
  
     ;; Write Symbols [{}]
     (setq-default mac-right-option-modifier nil)

     ;; GPG
     (setf epa-pinentry-mode 'loopback)

     ;; Freench Locale
     (set-locale-environment "fr_FR.UTF-8"))
 #+end_src
** Uniquify

Uniquify file path to ensure buffer name uniqueness

#+begin_src emacs-lisp
  (use-package uniquify
    :straight nil
    :custom
    (uniquify-buffer-name-style 'forward)
    (uniquify-separator "/")
    (uniquify-after-kill-buffer-p t)
    (uniquify-ignore-buffers-re "^\\*")
  )
#+end_src
** Recent Files

 #+BEGIN_QUOTE
 Recentf is a minor mode that builds a list of recently opened
 files. This list is is automatically saved across sessions on exiting
 Emacs - you can then access this list through a command or the menu.

 [[https://www.emacswiki.org/emacs/RecentFiles][https://www.emacswiki.org/emacs/RecentFiles]]
 #+END_QUOTE

 #+begin_src emacs-lisp
   (use-package recentf
     :straight nil
     :custom
     (recentf-auto-cleanup "09:00am")
     (recentf-max-saved-items 300)
     (recentf-exclude '((expand-file-name package-user-dir)
                        ".cache"
                        ".cask"
                        ".elfeed"
                        "bookmarks"
                        "cache"
                        "ido.*"
                        "persp-confs"
                        "recentf"
                        "undo-tree-hist"
                        "url"
                        "COMMIT_EDITMSG\\'")))

   ;; When buffer is closed, saves the cursor location
   (save-place-mode 1)

   (recentf-mode 1)

   ;; Set history-length longer
   (setq-default history-length 500)

 #+end_src
** Repeat Mode
Toggle Repeat Mode
#+begin_src emacs-lisp
  (repeat-mode)
#+end_src
 
* UI
:properties:
:header-args+: :tangle "./lisp/setup-ui.el"
:end:

UI configuration module automatically tangled in =./lisp/setup-ui.el=

#+begin_src emacs-lisp :noweb yes
  ;;; setup-ui.el --- UI configuration module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src
** Minimalistic UI
*** No menu and toolbar

#+begin_src emacs-lisp
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+end_src

*** No welcome screen

#+begin_src emacs-lisp
(setq  inhibit-startup-message t)
#+end_src

*** Make fringe smaller

#+begin_src emacs-lisp
  (if (fboundp 'fringe-mode)
      (fringe-mode 2))
#+end_src
** All The Icons
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src
** Theme
Using moe theme dark all the day
#+begin_src emacs-lisp
  (use-package doom-themes

    :config

    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; Load the theme (doom-one, doom-molokai, etc); keep in mind that each theme
    ;; may have their own settings.
    (load-theme 'doom-one t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)

    ;; or for treemacs users
    (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
    (doom-themes-treemacs-config)
    ;;(doom-themes-treemacs-config)

    ;; Corrects (and improves) org-mode's native fontification.
    (with-eval-after-load 'org-mode
        (doom-themes-org-config))
    )
#+end_src
** Mode line
#+begin_src emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode))
#+end_src

** Font

#+begin_src emacs-lisp
  (defun nc/setup-font ()
    "Set up font height"
    (interactive)
    (when is-linux
      (set-frame-font "Jetbrains Mono 13" nil t))
    (when is-mac
      (if (> (display-pixel-width) 2500)
          (set-frame-font "Jetbrains Mono 16" nil t)
          (set-frame-font "Jetbrains Mono 14" nil t)))
    (when is-windows
      (set-frame-font "Jetbrains Mono 10" nil t))
    )

  (when has-gui
    (add-hook 'after-init-hook #'nc/setup-font))
#+end_src
** Emojify

ℹ️ All-The-Icons and Noto Emoji should be installed

#+begin_src emacs-lisp
  (setf use-default-font-for-symbols nil)
  (set-fontset-font t 'unicode "Noto Emoji" nil 'append)

  (use-package emojify
      :hook (after-init . global-emojify-mode)
      :config

      (set-fontset-font "fontset-default" 'symbol "Noto Color Emoji" nil 'append)
      (set-fontset-font "fontset-default" 'symbol "Symbola" nil 'append)
      (set-fontset-font t 'unicode (font-spec :family "all-the-icons") nil 'append)
      (set-fontset-font t 'unicode (font-spec :family "file-icons") nil 'append)
      (set-fontset-font t 'unicode (font-spec :family "Material Icons") nil 'append)
      (set-fontset-font t 'unicode (font-spec :family "github-octicons") nil 'append)
      (set-fontset-font t 'unicode (font-spec :family "FontAwesome") nil 'append)
      (set-fontset-font t 'unicode (font-spec :family "Weather Icons") nil 'append)

      ;; (add-hook 'markdown-mode-hook 'ac-emoji-setup)

      (require 'font-lock))
#+end_src
** Casual
Contextual User Interfaces based on Transient (aka magit interface)
*** casual-editkit
User interface library for Emacs editing commands.
#+begin_src emacs-lisp
  ;; (use-package casual-editkit
  ;;       :ensure nil
  ;;       :bind (("<f2>" . casual-editkit-main-tmenu)))
#+end_src

* Key Bindings
:properties:
:header-args+: :tangle "./lisp/setup-keys.el"
:end:
Key bindings configuration module automatically tangled in =./lisp/setup-keys.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-keys.el --- Key Bindings module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src
** Global Key Bindings
Some Emacs Global Bindings are redefined here.
#+begin_src emacs-lisp
  ;; Unbind unneeded keys
  (global-set-key (kbd "C-z") nil)
  (global-set-key (kbd "C-l") nil)
  (global-set-key (kbd "M-z") nil)
  (global-set-key (kbd "C-x C-z") nil)
  (global-set-key (kbd "M-o") nil)
  (global-set-key (kbd "M-SPC") nil)


  (global-set-key (kbd "C-+") #'text-scale-increase)
  (global-set-key (kbd "C--") #'text-scale-decrease)

  ;; Prefer backward-kill-word over Backspace
  (global-set-key (kbd "C-w") #'backward-kill-word)
  (global-set-key (kbd "C-x C-k") #'kill-region)

  (global-set-key (kbd "C-x C-r") #'recentf-open-files)

  ;; Move up/down paragraph
  (global-set-key (kbd "M-n") #'forward-paragraph)
  (global-set-key (kbd "M-p") #'backward-paragraph)
  (global-set-key (kbd "C-x c") #'compile)


  ;; Functions
  (bind-keys
   ("<f5>" . revert-buffer)
   ("C-<f5>" . magit-log-buffer-file)
   ("<f9>" . treemacs)
   ("<f11>" . nc/maximize-or-split-window-vertically)
   ("C-<f11>" . nc/split-window-horizontally)
   ("<f12>" . org-agenda)
   ("C-<f12>" . org-agenda))

  ;; Tools alt-[0-9]
  (bind-keys
   ("M-0" . nc/maximize-or-split-window-vertically))
#+end_src
** TODO Hydra



#+begin_src emacs-lisp
  (use-package hydra
    :ensure t
    :custom
    (hydra-default-hint nil))

  (use-package major-mode-hydra
    :ensure t)

  ;; Pretty Hydra
  (use-package pretty-hydra
    :ensure t)
#+end_src
*** nc-hydra-insert 
#+begin_src emacs-lisp
  (pretty-hydra-define nc-hydra-insert (:foreign-keys warn :title "Insert" :quit-key "q" :exit t)
    ("Insert"
     (("d" nc/insert-datestamp-inactive "Date InActive")
      ("D" nc/insert-datestamp "Date Active")
      ("p" nc/generate-password "Password")
      ("u" nc/uuid "UUID"))

     "Snippet"
     (("y" consult-yasnippet "Yasnippet")
      ("Y" yankpad-insert "Yankpad"))))
#+end_src

*** nc-hydra-goto 
#+begin_src emacs-lisp
  (pretty-hydra-define nc-hydra-goto (:foreign-keys warn :title "Goto" :quit-key "q" :exit t)
    ("Configuration"
     ((";" nc/goto-emacs-config "Emacs Config"))

      "Personal Files"
      (("i" nc/goto-inbox "Inbox")
       ("p" nc/goto-my-credentials "Passwords"))

     "Personal Dirs"
     (("A" nc/goto-archives-dir "Archives")
      ("N" nc/goto-notes-dir "Notes")
      ("P" nc/goto-projects-dir "Projects")
      ("T" nc/goto-templates-dir "Templates"))))
#+end_src

*** nc-hydra-toggles 
#+begin_src emacs-lisp
  (pretty-hydra-define nc-hydra-toggle
    (:color amaranth :quit-key "q" :title "Toggles")
    ("Basic"
     (("n" linum-mode "line number" :toggle t)
      ("w" whitespace-mode "whitespace" :toggle t)
      ;;("W" whitespace-cleanup-mode "whitespace cleanup" :toggle t)
      ("r" rainbow-mode "rainbow" :toggle t))
     "Highlight"
     (("l" hl-line-mode "line" :toggle t))
     "Coding"
     (("p" smartparens-mode "smartparens" :toggle t)
      ("P" smartparens-strict-mode "smartparens strict" :toggle t)
      ("S" show-smartparens-mode "show smartparens" :toggle t)
      ("e" eldoc-mode "eldoc" :toggle t))
     "Emacs"
     (("D" toggle-debug-on-error "debug on error" :toggle (default-value 'debug-on-error))
      ("X" toggle-debug-on-quit "debug on quit" :toggle (default-value 'debug-on-quit)))))
#+end_src
*** hydra windows
#+begin_src emacs-lisp
  (pretty-hydra-define nc-hydra-windows
      (:color amaranth :quit-key "q" :title "Windows" :exit t)
      ("Move"
       (("v" nc/maximize-or-split-window-vertically "Maximize or Split Window V")
        ("h" nc/split-window-horizontally "Split Window H"))))
#+end_src

*** hydra org-mode
#+begin_src emacs-lisp
  (major-mode-hydra-define org-mode nil
    ("GTD"
     (("s" nc/org-insert-daily-review "Start Daily Review")
      ("d" nc/insert-daily-heading "Insert Daily Heading"))
     "Actions"
     (("r" nc/org-refile-subtree-to-file "Refile subtree to file")
      ("A" nc/create-buffer-attachment-directory "Create attachment directory"))
     "Search"
     (("?" nc/search-notes "Search Notes"))))
#+end_src

** Key Chords

#+begin_src emacs-lisp
  (use-package key-chord
    :init
    (key-chord-mode 1)
    (key-chord-define-global "FF" 'projectile-find-file)
    (key-chord-define-global "::" 'avy-goto-char-timer)
    (key-chord-define-global "GG" 'consult-ripgrep)  
    (key-chord-define-global "OO" 'consult-outline)
    (key-chord-define-global "DD" 'delete-region)
    (key-chord-define-global "??" 'nc/search-notes) 
    (key-chord-define-global "BB" 'beginning-of-buffer)
    (key-chord-define-global "JJ" 'crux-top-join-line)
    (key-chord-define-global "MM" 'nc/maximize-or-split-window-vertically)
    (key-chord-define-global "$$" 'end-of-buffer))
#+end_src

** Which Key

[[https://github.com/justbur/emacs-which-key][Which Key]] is a minor mode for Emacs that displays the key bindings following
your currently entered incomplete command (a prefix) in a popup.

#+begin_src emacs-lisp
  (use-package which-key
    :diminish
    :custom
    (which-key-separator " ")
    (which-key-prefix-prefix "+")
    :config
    (which-key-mode)
    (which-key-enable-god-mode-support))
#+end_src
** My Universal Key Binding

🚧 Experimental : inspired by https://summeremacs.github.io/posts/universal-keybind/ 

See also : https://github.com/pivaldi/pimacs/tree/master/doc

#+begin_src emacs-lisp

(global-set-key (kbd "C-q") nil)

(defvar-keymap prefix-buffer-map-d
  :doc "Prefix map for C-q for dired/Denote"
  "j" #'dired
  "s" #'denote-sort-dired
  ;; "d" prefix-buffer-map-denote
  )


(defvar-keymap prefix-buffer-map-i
    :doc "Prefix map for C-q for Insert"
    "d" #'nc/insert-datestamp-inactive
    "D" #'nc/insert-datestamp
    "p" #'nc/generate-password
    "t" #'tempel-insert
    "u" #'nc/uuid
    "y" #'consult-yasnippet
    "Y" #'yankpad-insert)

(defvar-keymap prefix-buffer-map-g
  :doc "Prefix map for C-q for goto my files or folders"
  ";" #'nc/goto-emacs-config
  "i" #'nc/goto-inbox
  "p" #'nc/goto-my-credentials
  "A" #'nc/goto-archives-dir
  "N" #'nc/goto-notes-dir
  "P" #'nc/goto-projects-dir
  "T" #'nc/goto-templates-dir
  )

(defvar-keymap prefix-buffer-map-j
  :doc "Prefix map for C-q for jump"
  "j" #'avy-goto-char-timer
  "i" #'imenu
  "o" #'occur
  "d" #'dired-jump)

(defvar-keymap prefix-buffer-map-s
  :doc "Prefix map for C-q for Search"
  "f" #'nc/consult-fd-my-projects
  "n" #'nc/search-notes
  "r" #'nc/consult-rg-my-projects)


(defvar-keymap prefix-buffer-map-t
  :doc "Prefix map for C-q for GTD/org mode"
  "D" #'toggle-debug-on-error
  "P" #'smartparens-strict-mode
  "S" #'show-smartparens-mode
  "X" #'toggle-debug-on-quit
  "e" #'eldoc-mode
  "l" #'hl-line-mode
  "n" #'linum-mode
  "p" #'smartparens-mode
  "r" #'rainbow-mode
  "t" #'treemacs
  "w" #'whitespace-mode)

(defvar-keymap prefix-command-q
  :doc "Prefix Map for C-q:"
  ";" #'nc/goto-emacs-config
  "a" #'embark-act
  "d" prefix-buffer-map-d
  "e" #'casual-editkit-main-tmenu
  "g" prefix-buffer-map-g
  "h" #'major-mode-hydra
  "i" prefix-buffer-map-i
  "j" prefix-buffer-map-j
  "s" prefix-buffer-map-s
  "t" prefix-buffer-map-t)


(which-key-add-keymap-based-replacements prefix-command-q
  "d" `("Dired/Denote" . ,prefix-buffer-map-d)
  ;; "d d" `("Denote" . ,prefix-buffer-map-denote)
  "g" `("Goto My Files" . ,prefix-buffer-map-g)
  "i" `("Insert" . ,prefix-buffer-map-i)
  "j" `("Jump" . ,prefix-buffer-map-j)
  "t" `("Toggles" . ,prefix-buffer-map-t)
  ;; "m m" `("Mark" . ,prefix-buffer-map-mark)
  ;;"c" `("Casual" . ,prefix-buffer-map-casual)
  "s" `("Search" . ,prefix-buffer-map-s))

(keymap-set global-map "C-q" prefix-command-q)

#+end_src


* Windows
:properties:
:header-args+: :tangle "./lisp/setup-windows.el"
:end:

Windows configuration module automatically tangled in =./lisp/setup-windows.el=

#+begin_src emacs-lisp :noweb yes
  ;;; setup-windows.el --- Windows configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src


** Ace Window
[[https://github.com/abo-abo/ace-window][ace-window]] Quickly switch and move windows

#+begin_src emacs-lisp
  (use-package ace-window
    :bind (([remap other-window] . ace-window)
           ("M-o" . ace-window))
    :config
    (setq aw-keys '(?q ?s ?d ?f ?g ?h ?j ?k ?l))
    ;; increase size face
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 3.0))))))
 #+end_src

** Golden Ratio

 [[https://github.com/roman/golden-ratio.el][Golden Ratio]] resize automatically the windows you are working

 #+begin_src emacs-lisp
   (use-package golden-ratio
     :diminish t
     :init
     (golden-ratio-mode 1)
     :config
     (setq golden-ratio-extra-commands
           (append golden-ratio-extra-commands
                   '(ace-window))))

   (defun nc/toggle-golden-ratio ()
     "Toggle golden ratio for widescreen"
     (interactive)
     (setq golden-ratio-adjust-factor .8))
 #+end_src


** Split Window Horizontally

Bound to =<my-prefix-map> w h=.
#+begin_src emacs-lisp
  (defun nc/split-window-horizontally ()
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))
#+end_src


** Maximize or Split Window Vertically 
Split window right with =<my-prefix-map> w v= and move there.
If windows are splitted delete other windows.
#+begin_src emacs-lisp
  (defun nc--split-window-right-and-move-there-dammit ()
    (split-window-right)
    (windmove-right))

  (defun nc/maximize-or-split-window-vertically ()
    (interactive)
    (if (> (count-windows) 1)
        (delete-other-windows)
      (nc--split-window-right-and-move-there-dammit)))
  #+end_src


* Core Packages
:properties:
:header-args+: :tangle "./lisp/setup-core.el"
:end:

Core packages configuration module automatically tangled in =./lisp/setup-core.el=

#+begin_src emacs-lisp :noweb yes
  ;;; setup-core.el --- Core packages configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src

** Avy

#+begin_src emacs-lisp
  (use-package avy
    :defer t
    :custom
    (avy-timeout-seconds 0.5)
    (avy-style 'pre)
    (avy-keys '(?q ?s ?d ?f ?g ?h ?j ?k ?l ?m))
    :bind
    (("C-:" . avy-goto-subword-1)
     ("s-j"   . avy-goto-char-timer))     ; start / opt 
    :custom-face
    (avy-lead-face ((t (:background "#51afef" :foreground "#870000" :weight bold)))))
    
#+end_src

** Crux
[[https://github.com/bbatsov/crux][Crux]] A Collection Of Ridiculosy Useful eXtensions for Emacs
#+begin_src emacs-lisp
  (use-package crux
    :bind
    (("C-a" . crux-move-beginning-of-line)
     ("C-c d" . crux-duplicate-current-line-or-region)
     ("C-x 4 t" . crux-transpose-windows)
     ("C-x K" . crux-kill-other-buffers)
     ("C-k" . crux-smart-kill-line)
     ("M-j" . crux-top-join-line))
    :config
    (crux-with-region-or-buffer indent-region)
    (crux-with-region-or-buffer untabify)
    (crux-with-region-or-point-to-eol kill-ring-save)
    (defalias 'rename-file-and-buffer #'crux-rename-file-and-buffer))
#+end_src

** Dired
*** Dired
#+begin_src emacs-lisp
  (use-package dired
    :straight nil
    :bind
    (("C-x C-j" . dired-jump)
     (:map dired-mode-map
                ("E" . wdired-change-to-wdired-mode)))
    
    :custom
    ;; Always delete and copy recursively
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always)
    ;; Auto refresh Dired, but be quiet about it
    (global-auto-revert-non-file-buffers t)
    (auto-revert-verbose nil)
    ;; Quickly copy/move file in Dired
    (dired-dwim-target t)
    ;; Move files to trash when deleting
    (delete-by-moving-to-trash t)
    ;; Load the newest version of a file
    (load-prefer-newer t)
    ;; Detect external file changes and auto refresh file
    (auto-revert-use-notify nil)
    (auto-revert-interval 3) ; Auto revert every 3 sec


    :config
    ;; Enable global auto-revert
    (global-auto-revert-mode t)

    (put 'dired-find-alternate-file 'disabled nil)
    ;; Using GNU ls on macOS instead of ls
    (if (executable-find "gls")
        (progn
          (setq insert-directory-program "gls")
          (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
      (setq dired-listing-switches "-ahlF"))


    ;; From https://www.emacs.dyerdwelling.family/emacs/20230606213531-emacs--dired-duplicate-here-revisited/
    (defun nc/dired-duplicate-file (arg)
      "Duplicate the current file in Dired."
      (interactive "p")
      (let ((filename (dired-get-filename)))
        (setq target (concat (file-name-sans-extension filename)
                             "-old"
                             (if (> arg 1) (number-to-string arg))
                             (file-name-extension filename t)))
        (if (file-directory-p filename)
            (copy-directory filename target)
          (copy-file filename target))
        )
      )

    (define-key dired-mode-map (kbd "C-c d") 'nc/dired-duplicate-file)


    :hook
    (dired-mode . (lambda ()
                    (local-set-key (kbd "<mouse-2>") #'dired-find-alternate-file)
                    (local-set-key (kbd "RET") #'dired-find-alternate-file)
                    (local-set-key (kbd "^")
                                   (lambda () (interactive) (find-alternate-file ".."))))))

#+end_src
*** Dired Narrow

[[https://github.com/Fuco1/dired-hacks/tree/7c0ef09d57a80068a11edc74c3568e5ead5cc15a#dired-narrow][Dired Narrow]] provides live filtering of files in dired buffers. In
general, after calling the respective narrowing function you type a
filter string into the minibuffer.

#+begin_src emacs-lisp
  (use-package dired-narrow
    :commands dired-narrow
    :after dired
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
#+end_src

*** Font Lock Dired

[[https://github.com/purcell/diredfl][Diredfl]] Extra font lock rules for a  more colorful dired.

#+begin_src emacs-lisp
   (use-package diredfl
    :init (diredfl-global-mode 1))
#+end_src
** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] Project interaction library for emacs.

#+begin_src emacs-lisp
  (use-package projectile
    :custom
    (projectile-sort-order 'recently-active)
    :config
    (projectile-global-mode)
    :init
      (setq projectile-enable-caching t)
      ;; Custom mode line
      (setq projectile-mode-line '(:eval (format " Ⓟ[%s]" (projectile-project-name))))
    :bind-keymap ("C-<f6>" . projectile-command-map))
#+end_src

** Expand region
#+BEGIN_QUOTE
Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.

[[https://github.com/magnars/expand-region.el]]
#+END_QUOTE

- expand selection with =C-==
- contract with negative argument =M--= then =C-==

 #+begin_src emacs-lisp
 (use-package expand-region
   :bind
   ("C-=" . er/expand-region))
 #+end_src

** Multiple Cursors

 [[https://github.com/magnars/multiple-cursors.el][multiple-cursors.el]] This package can create several cursors to all do the same things.

 #+begin_src emacs-lisp
   (use-package multiple-cursors
     :bind
     (("C-S-c C-S-c" .  mc/edit-lines)
      ("C-$" .  mc/edit-ends-of-lines)
      ("C-S-b" .  mc/edit-beginnings-of-lines)
      ;; Conflict my own map
      ;("C-<" .  mc/mark-previous-word-like-this) 
      ;("C->" .  mc/mark-next-word-like-this)
      ("C-S-n" .  mc/mark-next-like-this)
      ("C-S-p" .  mc/mark-previous-like-this)
      ("C-*" .  mc/mark-all-dwim)))
 #+end_src

** Undo Tree
 This lets you use =C-x u= (=undo-tree-visualize=)
 #+begin_src emacs-lisp
   (use-package undo-tree
     :diminish undo-tree-mode
     :config
     (progn
       (global-undo-tree-mode)
       (setq undo-tree-visualizer-timestamps t)
       (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/var/undo")))
       (setq undo-tree-visualizer-diff t)))
 #+end_src

** Ediff

 From : [[https://www.emacswiki.org/emacs/EdiffMode]]

 You can ignore whitespace or case sensitivity in two ways:
- Interactively, on the fly:
   - Whitespace sensitivity – Toggle with =##= (=ediff-toggle-skip-similar=).
   - Case sensitivity – Toggle with =#c= (=ediff-toggle-ignore-case=). This assumes that you’ve loaded library Lisp:ediff+.el and that you are using `diff(1)’ as ‘ediff-diff-program’. (Toggling case-sensitivity is available in vanilla GNU Emacs 22, so Lisp:ediff+.el is mainly useful for older Emacs versions.)
 - Persistently: Customize option =ediff-diff-options=. This assumes that you are using `diff(1)’ as ‘ediff-diff-program’.
    - Whitespace insensitivity – Include ‘-w’ in =ediff-diff-options=.
    - Case insensitivity – Include ‘-i’ in =ediff-diff-options=.

#+begin_src emacs-lisp
  (use-package ediff
    :straight nil
    :custom
     ;; Ediff should be opened in selected frame and split window horizontally
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-diff-options "-w")
    :config
    ;; Pour éviter des ouvertures de frames intempestives
    (advice-add 'ediff-window-display-p :override 'ignore))
#+end_src


** Magit

#+BEGIN_QUOTE
Magit a git porcelain inside Emacs !

[[https://github.com/magit/magit]]
#+END_QUOTE

#+begin_src emacs-lisp
  (use-package magit

    :init
    (when (getenv "GIT_EXECUTABLE")
      (setq magit-git-executable (getenv "GIT_EXECUTABLE")))
    :commands (magit-status magit-get-current-branch)

    :bind ("C-x g" . magit-status))
#+end_src


** Treemacs

#+begin_quote
Treemacs - A tree layout file explorer for Emacs

https://github.com/Alexander-Miller/treemacs
#+end_quote

I have a very simple use of treemacs
Cf https://github.com/Alexander-Miller/treemacs#navigation-without-projects-and-workspaces 


#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :bind (:map global-map
                ("M-à" . treemacs-select-window)
                ("M-0" . treemacs-select-window)
                ("C-x t t" . treemacs)
                ("C-x t 1" . treemacs-delete-other-windows))
    :custom
    (treemacs-is-never-other-window t)
    (treemacs-persist-file (expand-file-name ".cache/treemacs-persist" user-emacs-directory))
    :hook
    (treemacs-mode . treemacs-project-follow-mode))

  ;; (use-package treemacs-projectile
  ;;   :after (treemacs projectile)
  ;;   :ensure t)

  (use-package treemacs-icons-dired
    :hook (dired-mode . treemacs-icons-dired-enable-once)
    :ensure t)
#+end_src

** Rainbow mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'rainbow-mode)
  (diminish 'rainbow-mode))
#+end_src

** Yasnippet
Snippets for programming.

 #+begin_src emacs-lisp
   (use-package yasnippet
     :ensure t
     :diminish yas-minor-mode
     :config
     (use-package yasnippet-snippets)
     :hook
     (after-init . yas-global-mode))
 #+end_src

Consult integration
#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :bind
    (:map global-map
     ("C-c y" . consult-yasnippet)))
#+end_src


#+begin_src emacs-lisp
  (use-package yasnippet-capf
    :after cape
    :config
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))



#+end_src

*** src block snippets helpers
Header Arg snippet Helpers from : https://github.com/tecosaur/emacs-config/blob/master/config.org#snippet-helpers

#+begin_src emacs-lisp
  (defun +yas/org-src-header-p ()
    "Determine whether `point' is within a src-block header or header-args."
    (pcase (org-element-type (org-element-context))
      ('src-block (< (point) ; before code part of the src-block
                     (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                     (forward-line 1)
                                     (point))))
      ('inline-src-block (< (point) ; before code part of the inline-src-block
                            (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                            (search-forward "]{")
                                            (point))))
      ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))


  (defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read values :prompt question :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src


** wgrep

#+begin_src emacs-lisp
  (use-package wgrep
    ;; Edit a grep buffer and apply those changes to the file buffer.
    ;; In other words, after searching for something, sending the
    ;; results to a buffer (via `embark-export' or such thing), you can
    ;; edit that search results buffer and propogate the changes to the
    ;; locations of the elements that matched the search.
    ;;
    ;;   1.  Call `consult-ripgrep' (via ~C-c f~) to search for something.
    ;;   2.  Call `embark-export' (via ~C-s-e~) to export to a grep
    ;;       buffer.
    ;;   3.  Call `wgrep-change-to-wgrep-mode' (via ~e~ or ~C-c C-p~)
    ;;   4.  Edit the grep buffer as you would anywhere else.
    ;;   5.  Save (via ~C-x C-s~) or Cancel (via ~C-c C-k~).
    :after (embark-consult ripgrep)
    :config (setq wgrep-auto-save-buffer t)
    (setq wgrep-change-readonly-file t)
    :straight t
    :bind (:map grep-mode-map
            ("e" . wgrep-change-to-wgrep-mode)
            :map ripgrep-search-mode-map
            ("e" . wgrep-change-to-wgrep-mode)))
#+end_src

* Completion
:properties:
:header-args+: :tangle "./lisp/setup-completion.el"
:end:

Completion configuration automatically tangled in =./lisp/setup-completion.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-completion.el --- Completion configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src

** Vertico

#+begin_src emacs-lisp
    ;; Enable vertico
    (use-package vertico
      :straight (:files (:defaults "extensions/*"))
      :init
      (vertico-mode)

      ;; Different scroll margin
      (setq vertico-scroll-margin 0)

      ;; Show more candidates
      (setq vertico-count 10)

      ;; Grow and shrink the Vertico minibuffer
     (setq vertico-resize t)

      ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
      ;; (setq vertico-cycle t)
      )

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode))


  ;; Optionally use the `orderless' completion style.
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src
** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :bind (:map minibuffer-local-map
                ("C-M-a" . marginalia-cycle))
    :init
    (marginalia-mode)
    (advice-add #'marginalia-cycle :after
                (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))
    (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src



** Consult

     [[https://github.com/minad/consult][Consult]] Consulting completion Read with some custom bindings :

#+begin_src emacs-lisp
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c b" . consult-bookmark)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x C-r" . consult-recent-file)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-fd)
           ("M-s F" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("C-s" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Custom searching
           ("C-c sf" . nc/consult-fd-my-projects)
           ("C-c sr" . nc/consult-rg-my-projects)
           ;; Isearch integration
           ("M-s e" . consult-isearch)
           :map isearch-mode-map
           ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

    ;; Enable automatic preview at point in the *Completions* buffer.
    ;; This is relevant when you use the default completion UI,
    ;; and not necessary for Vertico, Selectrum, etc.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)


    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    (defun nc/consult-rg-my-projects ()
      (interactive)
      (consult-ripgrep "~/Projects"))
    (defun nc/consult-fd-my-projects ()
      (interactive)
      (consult-fd "~/Projects"))

    
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key (kbd "M-.")
     :preview-key '(:debounce 0.4 any))



    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (project-roots)
    (setq consult-project-root-function
          (lambda ()
            (when-let (project (project-current))
              (car (project-roots project)))))
    ;;;; 2. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-root-function #'projectile-project-root)
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
  )


  (use-package consult-dir
    :ensure t
    :bind (("C-x C-d" . consult-dir)
         :map vertico-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file))
    :config
    (setq consult-dir-project-list-function #'consult-dir-projectile-dirs))




#+end_src
** Embark

[[https://github.com/oantolin/embark][Embark]] Emacs Minibuffer Actions Rooted in Key Maps

#+begin_src emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init

    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))

    ;; Custom some actions
    (define-key embark-defun-map "j" 'crux-top-join-line)
    (define-key embark-symbol-map "j" 'crux-top-join-line)
    (define-key embark-expression-map "j" 'crux-top-join-line)

    (define-key embark-file-map (kbd "S") 'nc/sudo-find-file))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))


#+end_src
** Completion at point
*** Hippie Expand

#+begin_src emacs-lisp
  (use-package hippie-exp
    :bind ([remap dabbrev-expand] . hippie-expand)
    :commands (hippie-expand)
    :custom
    (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'"))
    :config
    (setq hippie-expand-try-functions-list
          '(try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill
            try-complete-lisp-symbol-partially
            try-complete-lisp-symbol
            try-complete-file-name-partially
            try-complete-file-name
            try-expand-all-abbrevs
            try-expand-list
            try-expand-line)))
#+end_src


*** Corfu

#+begin_src emacs-lisp
  (use-package corfu
    :straight (corfu :files (:defaults "extensions/*")
                     :includes
                     (corfu-history    ;; corfu-history-mode remembers selected candidates and sorts the candidates by their history position.
                      corfu-info       ;; Actions to access the candidate location and documentation.
                      corfu-popupinfo  ;; Display candidate documentation or source in a popup next to the candidate menu.
                      ))

    ;; Optional customizations
    :custom
    (corfu-cycle t)                 ; Allows cycling through candidates
    (corfu-auto t)                  ; Enable auto completion
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.25)
    (corfu-popupinfo-delay '(0.5 . 0.2))
    (corfu-preview-current 'insert) ; Do not preview current candidate
    (corfu-preselect-first nil)
    (corfu-on-exact-match nil)      ; Don't auto expand tempel snippets

    ;; Optionally use TAB for cycling, default is `corfu-complete'.
    :bind (:map corfu-map
                ("M-SPC"      . corfu-insert-separator)
                ("TAB"        . corfu-next)
                ([tab]        . corfu-next)
                ("S-TAB"      . corfu-previous)
                ([backtab]    . corfu-previous)
                ("<return>" . corfu-insert)
                ("C-q"        . corfu-quit))
    
    :init
    (global-corfu-mode)
    (corfu-history-mode)
    (corfu-popupinfo-mode) ; Popup completion info
    :config
    (add-hook 'eshell-mode-hook
              (lambda () (setq-local corfu-quit-at-boundary t
                                     corfu-quit-no-match t
                                     corfu-auto nil)
                (corfu-mode))))
#+end_src

*** Cape
Bound to =C-c p=
#+begin_src emacs-lisp
  (use-package cape
    :defer 10
    :bind (("C-c p p" . completion-at-point)
           ("C-c p d" . cape-dabbrev)
           ("C-c p h" . cape-history)
           ("C-c p f" . cape-file)
           ("C-c p k" . cape-keyword)
           ("C-c p a" . cape-abbrev)
           ("C-c p e" . cape-emoji)
           ("C-c p l" . cape-line)
           ("C-c p w" . cape-dict)
           ("C-c p &" . cape-sgml)
           ("C-c p r" . cape-rfc1345))
    :init
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (defalias 'dabbrev-after-2 (cape-capf-prefix-length #'cape-dabbrev 2))
    (add-to-list 'completion-at-point-functions 'dabbrev-after-2 t)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-abbrev)
    (add-to-list 'completion-at-point-functions #'yasnippet-capf)
    (cl-pushnew #'cape-file completion-at-point-functions)
    :config
    ;; Silence then pcomplete capf, no errors or messages!
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

    ;; Ensure that pcomplete does not write to the buffer
    ;; and behaves as a pure `completion-at-point-function'.
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify))
#+end_src
*** kind-icon

#+begin_src emacs-lisp
  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
    (kind-icon-blend-frac 0.08)

    ;; NOTE 2022-02-05: `kind-icon' depends `svg-lib' which creates a cache
    ;; directory that defaults to the `user-emacs-directory'. Here, I change that
    ;; directory to a location appropriate to `no-littering' conventions, a
    ;; package which moves directories of other packages to sane locations.
    (svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ; Change cache dir
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

  
    )

#+end_src
** Tempel
Template system perhaps should not be there...
Cf https://github.com/minad/tempel
#+begin_src emacs-lisp

  ;; Configure Tempel
  (use-package tempel
    ;; Require trigger prefix before template name when completing.
    :custom
    (tempel-trigger-prefix "<")

    :bind (("M-+" . tempel-complete) ;; Alternative tempel-expand
           ("M-*" . tempel-insert))

    :config
    (setq tempel-path (expand-file-name "templates" (concat (getenv "PIM_HOME") "/config/emacs")))

    :init

    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand
                        completion-at-point-functions)))

    (add-hook 'conf-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)

    ;; Optionally make the Tempel templates available to Abbrev,
    ;; either locally or globally. `expand-abbrev' is bound to C-x '.
    (add-hook 'prog-mode-hook #'tempel-abbrev-mode)
    (global-tempel-abbrev-mode)
  )

  ;; Optional: Add tempel-collection.
  ;; The package is young and doesn't have comprehensive coverage.
  ;;(use-package tempel-collection)


#+end_src


* Org
:properties:
:header-args+: :tangle "./lisp/setup-org.el"
:end:

Org mode configuration automatically tangled in =./lisp/setup-org.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-org.el --- Org mode configuration file -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src


** Org Base Configuration

#+begin_src emacs-lisp
(use-package org

  :bind (("C-c c" . org-capture)
         ("C-c a" . org-agenda)
         ("C-c C-b" . org-iswitchb))

  :config
  ;; New template exapnsion
  (require 'org-tempo)

  (setq org-ellipsis " ⬇"
        org-cycle-separator-lines 0                 ;; Hide empty lines between subtrees
        org-catch-invisible-edits 'show-and-error   ;; Avoid inadvertent text edit in invisible area
        )

  (set-face-attribute 'org-ellipsis nil :underline nil)

  ;; Autamatically add =ID= (unique identifier) in heading drawers to keep links unique
  (require 'org-id)
  (setq org-id-method 'uuidgen)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

  (require 'org-crypt)
  (org-crypt-use-before-save-magic)

  (add-to-list 'org-tags-exclude-from-inheritance "crypt")
  ;; GPG key to use for encryption
  ;; Either the Key ID or set to nil to use symmetric encryption.
  (setq org-crypt-key "0DF2D6C6E8443FE7")


  :hook
  ;; Redisplau inline images
  (org-babel-after-execute . org-redisplay-inline-images)
  )

 (use-package org-contrib)
#+end_src

** Org UI
*** Org Bullets

#+begin_src emacs-lisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode)
  :after org
  :custom (org-bullets-bullet-list '("◉" "✿" "★" "•")))

;; Hiding leading bullets in headers
(setq org-hide-leading-stars t)
#+end_src

*** Org Heading Styles

#+begin_src emacs-lisp
  (let* ((variable-tuple (cond ((x-list-fonts "Jetbrains Mono") '(:font "Jetbrains Mono"))
                               ((x-list-fonts "Monaco") '(:font "Monaco"))
                               ((x-list-fonts "Input Sans") '(:font "Input Sans"))
                               ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                               ((x-list-fonts "Verdana")         '(:font "Verdana"))
                               ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                               (nil (warn "Cannot find a Sans Serif Font.  Install Open Sans."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight normal :foreground ,base-font-color)))

    (custom-theme-set-faces 'user
                            '(org-special-keyword  ((t (:inherit (font-lock-comment-face fixed-pitch)) :foreground "#69ffeb")))

                            `(org-level-8 ((t (,@headline ,@variable-tuple))))
                            `(org-level-7 ((t (,@headline ,@variable-tuple))))
                            `(org-level-6 ((t (,@headline ,@variable-tuple))))
                            `(org-level-5 ((t (,@headline ,@variable-tuple))))
                            `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                            `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.2 :foreground "#ff8a69"))))
                            `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.3 :foreground "#ffd569"))))
                            `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.4 :foreground "#ffaf69"))))
                            `(org-document-title ((t (,@headline ,@variable-tuple :height 1.6 :underline nil :foreground "#e6b68d"))))
                            `(org-document-info         ((t (:foreground "#697dff"))))
                            `(org-document-info-keyword         ((t (:foreground "#697dff"))))
                            `(header-line ((t (:background "#697dff" :height 220))))
                            '(org-special-keyword-face ((t (:foreground "#697dff"))))

                            '(org-block-begin-line ((t (:foreground "#69ffeb"))))
                            '(org-verbatim ((t (:foreground "#69ffeb"))))
                            '(org-table ((t (:foreground "#fae196"))))
                            `(org-checkbox ((t (:foreground "#ff4c4f"
                                           :box (:line-width 1 :style released-button)))))
                            `(org-date ((t (:foreground "#69ffeb"))))
                            `(org-tag ((t (:foreground "#e6b68d"))))

                            `(org-checkbox-statistics-todo ((t (:foreground "#ff4c4f"))))
                            '(org-list-dt               ((t (:foreground "#ff4c4f"))))
                            '(org-link                  ((t (:foreground "#697dff" :underline t))))))
#+end_src


*** org-fancy-priorities

#+begin_src emacs-lisp
  (use-package org-fancy-priorities
        :diminish
        :defines org-fancy-priorities-list
        :hook (org-mode . org-fancy-priorities-mode)
        :config (setq org-fancy-priorities-list '("⚡" "▲" "▲" "▼")))

#+end_src

Change priorities colors

#+begin_src emacs-lisp
(setq org-lowest-priority ?D
        org-default-priority ?D
        org-priority-faces '((?A . (:foreground "red" :weight bold))
                             (?B . (:foreground "orange"))
                             (?C . (:foreground "yellow"))
                             (?D . (:foreground "green"))))
#+end_src


*** Startup Indented
#+begin_src emacs-lisp
  (setq org-startup-indented t
        org-pretty-entities t
        ;; show actually italicized text instead of /italicized text/
        org-hide-emphasis-markers t
        org-fontify-quote-and-verse-blocks t)
#+end_src


** My Org Files

 My default org files

 #+begin_src emacs-lisp
   (use-package org
     :custom
     (org-directory "~/notes")
     :config

     (defconst nc/org-projects-file (concat org-directory "/projects.org"))
     (defconst nc/org-office-file (concat org-directory "/office.org"))
     (defconst nc/org-default-archives-dir (concat org-directory "/archives"))
     (defconst nc/org-default-templates-dir (concat org-directory "/templates"))
     (defconst nc/org-default-personal-dir (concat org-directory "/personal"))
     (defconst nc/org-journal-dir (concat org-directory "/journal"))
     (defconst nc/inbox-file (concat org-directory "/gtd.org"))
     (defconst nc/org-default-inbox-file (concat org-directory "/gtd.org"))
     (defconst nc/org-default-tasks-file (concat org-directory "/gtd.org"))
     (defconst nc/watching-file (concat org-directory "/personal/watching.org"))
     (defconst nc/reading-file (concat org-directory "/personal/books.org"))
     (defconst nc/org-default-media-files (concat org-directory "/personal/watching.org"))
     (defconst nc/org-default-someday-file (concat org-directory "/someday.org"))
     (defconst nc/fishing-file (concat org-directory "/personal/sports/fishing.org"))
     (defconst nc/calendar-file (concat org-directory "/personal/calendar.org"))
     (defconst nc/weekly-review-file (concat org-directory "/personal/reviews/weekly-review.org"))


     (defun nc/goto-inbox ()
       (interactive)
       (find-file nc/inbox-file )
       (widen)
       (beginning-of-buffer)
       (re-search-forward "* Inbox")
       (beginning-of-line))

     (defun nc/goto-notes-dir ()
       (interactive)
       (dired org-directory))

     (defun nc/goto-archives-dir ()
       (interactive)
       (dired nc/org-default-archives-dir))

     (defun nc/goto-templates-dir ()
       (interactive)
       (dired nc/org-default-templates-dir))

     (defun nc/goto-projects-dir ()
       (interactive)
       (dired (nc/projects-dir)))
   
     (defun nc/projects-dir ()
       "Return projects dir"
       (interactive "P")
       (cond
        (is-windows "~/Projects/")
        (t "~/Projects")))
   )
 #+end_src


** Journal
 Function to easily load weekly journal
 #+begin_src emacs-lisp

   (defun nc/goto-journal-file ()
         "Create and load a journal file based on today's date."
         (interactive)

         (find-file (nc--get-journal-file-today)))

   (defun nc--get-journal-file-today ()
         "Return today's journal file."
         (let ((daily-name (format-time-string "%Y-W%W")))
           (expand-file-name (concat nc/org-journal-dir "/" daily-name ".org"))))

   (setq org-default-notes-file (nc--get-journal-file-today))

   (bind-key "C-c n j" 'nc/goto-journal-file)
 #+end_src


   #+begin_src emacs-lisp
     (defun nc--autoinsert-yas-expand ()
       "Replace text in yasnippet template."
       (yas-expand-snippet (buffer-string) (point-min) (point-max)))

     (setq auto-insert 'other
           auto-insert-directory nc/org-default-templates-dir)

     (define-auto-insert "\\.org\\'" ["week.org" nc--autoinsert-yas-expand])

     (defun nc--get-current-day ()
       "Returns current day name"
       (s-upper-camel-case (format-time-string "%A")))

     (defun nc/journal-file-insert (current-day)
       "Insert's the journal heading based on the file's name."

       (insert (concat current-day " " (format-time-string "%d %B %Y")))


       ;; Note: The `insert-file-contents' leaves the cursor at the
       ;; beginning, so the easiest approach is to insert these files
       ;; in reverse order:

       ;; If the journal entry I'm creating matches today's date:

       ;; Insert dailies that only happen once a week:
       (let ((weekday-template (downcase
                                (concat nc/org-default-templates-dir (format "/journal/%s.org" current-day)))))
         (when (file-exists-p weekday-template)
           (insert-file-contents weekday-template)))

       (insert "\n"))


     (defun nc/insert-daily-heading ()
       "Insert Daily Heading in journal file"
       (interactive)
       (let ( (header-title (format-time-string "%Y-W%W" ))
              (current-day (nc--get-current-day)))
         ;; Don't change location of point.
         (goto-char (point-min)) ;; From the beginning...
         (if (search-forward header-title)
             ;;(end-of-line)
             (progn
               (org-insert-heading-after-current)
               (nc/journal-file-insert current-day)
               (if (search-backward current-day)
                   (beginning-of-line))
               (org-shiftmetaright))
           (error "Insert failed"))))
   #+end_src

** Tasks
My Todos tasks
  - parentheses indicate keyboard shortcuts
  - =@= prompts for a note
  - =!= logs the timestamp of the state change

 #+begin_src emacs-lisp
   (setq org-todo-keywords
    '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
      (sequence "STARTED(s)" "HOLD(h/!)" "|" "CANCELLED(c@/!)")
      (sequence "MEETING(m)" "RDV(r)"  "|" "DONE(d)")))
 #+end_src

Keep track when the task is completed.
 #+begin_src emacs-lisp
 (setq org-log-done nil)
 #+end_src

 Tasks faces : colors from https://flatuicolors.com/

 #+begin_src emacs-lisp
   (setq org-todo-keyword-faces
         (quote (("TODO" :foreground "#c0392b" :weight bold)
                 ("NEXT" :foreground "#d35400" :weight bold)
                 ("STARTED" :foreground "#f39c12" :weight bold)
                 ("HOLD" :foreground "#3498db" :weight bold)
                 ("DONE" :foreground "#27ae60" :weight bold)
                 ("MEETING" :foreground "#e6b68d" :weight bold)
                 ("RDV" :foreground "#e6b68d" :weight bold)
                 ("CANCELLED" :foreground "#7f8c8d" :weight bold))))
 #+end_src

** Tags (contexts)
In GTD tags are contexts
 #+begin_src emacs-lisp
   (setq org-tag-alist (quote ((:startgroup)
                               ("@office" . ?o)
                               ("@home" . ?h)
                               (:endgroup)
                               ("personal" . ?p)
                               ("@reading" . ?r)
                               ("learning" . ?l)
                               ("emacs" . ?e)
                               (:newline)
                               ("HOLD" . ?H)
                               ("CANCELLED" . ?c))))

   ;;(setq org-fast-tag-selection-single-key nil)
 #+end_src

Projects are marked with the =project= tag. They are supposed to
contain todo items, and are considered stuck unless they do. The
=project= tag should not be inheritable, because otherwise its tasks
will appear as projects.
 #+begin_src emacs-lisp
     (setq org-tags-exclude-from-inheritance '("project")
           org-stuck-projects '("+project/-DONE"
                                ("TODO" "NEXT") ()))
 #+end_src

** Capture templates

 #+begin_src emacs-lisp
 (setq org-capture-templates
       '(("p" "Personal")
         ("pp" "Project" entry
          (file nc/org-projects-file)
          "* %^{ProjectName} :project:\nDEADLINE: %^t\n:PROPERTIES:\n:STARTDATE: %U\n:CATEGORY: %^{category}\n:END:\n %?")
         ("pt" "Todo" entry
          (file nc/org-projects-file)
          "* TODO %?" :refile-targets ((nil :maxlevel . 1))
          :prepend t)
         ("o" "@office")
         ("op" "Project" entry
          (file nc/org-office-file)
          "* %^{ProjectName}:project:\nDEADLINE: %^t\n:PROPERTIES:\n:STARTDATE: %U\n:CATEGORY: %^{category}\n:END:\n %?")
         ("ot" "Todo" entry
          (file nc/org-office-file)
          "* TODO %?" :refile-targets ((nil :maxlevel . 1))
          :prepend t)
         ("t" "Task Entry"        entry
          (file+headline nc/inbox-file "Inbox")
          "* TODO %?\n:PROPERTIES:\n:CREATED:%U\n:END:\n\n%i\n\nFrom: %a"
          :empty-lines 1)
         ("s" "Someday" entry (file+headline nc/inbox-file "Inbox")
          "* SOMEDAY %? :idea:\n%u" :clock-in t :clock-resume t)
         ("f" "FishLog" plain (file+olp+datetree nc/fishing-file)
          "%[~/notes/templates/fishlog.org]" :time-prompt t)
         ("F" "Film" entry (file+headline nc/watching-file "Films")
          "* NEXT %^{Titre}
        %i
        - *Réalisateur:* %^{Auteur}
        - *Année:* %^{année}
        - *Genre:* %^{genre}

       %?

       %U" :prepend t)


         ("D" "Done Business Task" entry
          (file+headline nc/inbox-file "Tasks")
          "* DONE %^{Task} :@office:"
          :clock-in t :clock-resume t)
         ))
 #+end_src
*** TODO Meeting
 Should be moved in gcal.org

 #+begin_src emacs-lisp
   (add-to-list 'org-capture-templates
                    `("m" "Meeting" entry  (file+headline nc/calendar-file "Réunions")
           ,(concat "* MEETING 📆 %? :meeting:\n"
                    "<%<%Y-%m-%d %a %H:00-%H:30>>")))
 #+end_src
*** TODO RendezVous
 Should be moved in gcal.org
 #+begin_src emacs-lisp
 (add-to-list 'org-capture-templates
                  `("a" "RendezVous" entry (file+headline nc/calendar-file "RendezVous")
                  "* RDV %? :rdv:\n%U\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n"))
 #+end_src
*** Link

 Bookmark entry are captured in journal Links heading.

 #+begin_src emacs-lisp
   (defun org-journal-find-bookmark ()
     ;; Open today's journal, but specify a non-nil prefix argument in order to
     ;; inhibit inserting the heading; org-capture will insert the heading.
     (nc/goto-journal-file)
     ;; Position point on the journal's top-level heading so that org-capture
     ;; will add the new entry as a child entry.

     (goto-char (point-min))
     (search-forward (concat "Links " (format-time-string "%Y-W%W"))))

   (add-to-list 'org-capture-templates
                  `("l" "Linkk" entry (function org-journal-find-bookmark)
                         "* %?\n  %i\n  From: %a" :empty-lines 1))
 #+end_src
*** Note
#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
                   '("n" "Note"  entry
                     (file+headline nc/inbox-file "Notes")
                     "* %(org-insert-time-stamp nil nil t) %?\n  %i \n  See: %a" :empty-lines 1))
#+end_src
*** Book
#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
                   '("b" "Book"  entry
                     (file+headline nc/reading-file "Inbox")
                     "* NEXT %^{Title} %^g\n:PROPERTIES:\n:author: %^{Author}\n:name: %^{Title}\n:END:\n\n%i\n\n" :empty-lines 1))
#+end_src
*** Interruption task
 #+begin_src emacs-lisp
   (add-to-list 'org-capture-templates
                `("i" "Interrupting task" entry
                  (function org-journal-find-location)
                  "* %^{Task}"
                  :clock-in t :clock-resume t))
 #+end_src


 #+begin_src emacs-lisp
   (defun my/capture-interruption-task ()
       "Interrupted Task"
       (interactive)
       (org-capture 4 "i"))
 #+end_src
*** Daily Review

 #+begin_src emacs-lisp
   (defun org-journal-find-location ()
    ;; Open today's journal, but specify a non-nil prefix argument in order to
    ;; inhibit inserting the heading; org-capture will insert the heading.
    (nc/goto-journal-file)
    ;; Position point on the journal's top-level heading so that org-capture
    ;; will add the new entry as a child entry.

    (goto-char (point-min)))

   (add-to-list 'org-capture-templates
                  `("d" "Review: Daily Review" entry (function org-journal-find-location)
                    (file "~/notes/templates/dailyreview.org")
                    :clock-in t :clock-resume t))
 #+end_src


 #+begin_src emacs-lisp
   (defun nc/org-insert-daily-review ()
     "Insert daily review in org file"
     (interactive)
     (progn
       (org-capture nil "d")
       (org-capture-finalize t)
       (org-clock-in)))
 #+end_src
*** WeeklyReview
 #+begin_src emacs-lisp
 (add-to-list 'org-capture-templates
                  `("w" "WeeklyReview" entry (file+olp+datetree nc/weekly-review-file)
            "* Summary of the week :REVIEW:\n%[~/notes/templates/review.org]" :time-prompt t))
 #+end_src

** Agenda
*** Agenda configuration
:PROPERTIES:
:ID:       6bcba8de-f453-4aab-9a9e-64e648678604
:END:
By default all files in GTD and journal folder will be in my agenda, to be searchable

#+begin_src emacs-lisp
;; My Org agenda-files
(defvar nc/org-agenda-files (list "~/notes/gtd.org" "~/notes/projects.org" "~/notes/office.org" "~/notes/personal/calendar.org" "~/notes/journal/"))
#+end_src


Setting =org-agenda-file-regexp= to include all numeric files (journal files)

#+begin_src emacs-lisp
  (setq org-agenda-file-regexp "\\`[^.].*\\.org\\'\\|[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$"
          org-agenda-files nc/org-agenda-files
          org-agenda-span 'day
          org-agenda-start-on-weekday nil
          org-agenda-skip-deadline-if-done t
          org-agenda-skip-scheduled-if-done t
          org-agenda-start-with-log-mode t
          org-agenda-block-separator nil
          org-deadline-warning-days 5)
#+end_src

*** Diary
 #+begin_src emacs-lisp
   (setq diary-file "~/notes/diary"
         org-agenda-include-diary t)
 #+end_src
*** Custom Agenda commands
**** Display Header parent

 #+begin_src emacs-lisp
 (defun nc--org-agenda-display-title ()
   "Display org title if necessary"
   (save-excursion
     (save-restriction
      (widen) 
      (let* ((heading-tags (org-get-tags)))
        (if (seq-contains-p heading-tags "project")
            (s-concat "\n"  " 🏗️ ")
          "")))))
 #+end_src
**** Agenda Commands

     #+begin_src emacs-lisp
     (require 'org-agenda)

     (setq org-agenda-custom-commands
           '(("," "Agenda"
              ((agenda "" ((org-agenda-sorting-strategy '(timestamp-up time-up priority-down category-keep))
                           (org-agenda-prefix-format " %i %-20:c%?-12t% s")))

                     (tags "@office+TODO=\"STARTED\""
                                ((org-agenda-overriding-header "\n:office: Started Tasks @office")
                                 (org-agenda-prefix-format " %i %-20:c [%e] ")
                                 ;;(org-agenda-prefix-format "%-27:(nc--org-agenda-format-parent 25)")
                                 (org-agenda-sorting-strategy '(priority-down todo-state-up category-keep))))
                     (tags "@office+TODO=\"NEXT\""
                                ((org-agenda-overriding-header "\n:office: Next Tasks @office")
                                 (org-agenda-prefix-format " %i %-20:c [%e] ")
                                 (org-agenda-skip
                                  '(org-agenda-skip-if 'deadline))
                                 ;;(org-agenda-files '("~/_PIM/notes/gtd.org"))
                                 (org-agenda-sorting-strategy '(priority-down todo-state-up category-keep))))
                     (tags-todo "inbox"
                          ((org-agenda-prefix-format "  %?-12t% s")
                           (org-agenda-overriding-header "\n▶️ Inbox")))
                     (tags "personal+TODO=\"STARTED\"|personal+TODO=\"NEXT\""
                                ((org-agenda-overriding-header "\n:house: My current tasks")
                                 (org-agenda-prefix-format " %i %-20:c [%e] ")
                                 (org-agenda-skip
                                  '(org-agenda-skip-if 'deadline))
                                 ;;(org-agenda-files '("~/_PIM/notes/gtd.org"))
                                 (org-agenda-sorting-strategy '(priority-down todo-state-down category-keep))))
                     (tags-todo "TODO=\"HOLD\""
                                ((org-agenda-overriding-header "\n⌛ Hold / Waiting Tasks")
                                 (org-agenda-prefix-format " %i %-20:c")                            
                                 (org-agenda-sorting-strategy '(priority-down todo-state-up category-keep))))
                     )
                    nil)
             ("g" . "GTD contexts")
                ("go" "Office" tags-todo "@office")
                ("gp" "Personal" tags-todo "personal")
                ("ge" "Emacs" tags-todo "emacs")
                ("gl" "Learning" tags-todo "learning")
                ("gr" "Reading" tags-todo "@reading")
                 ;; exports block to this file with C-c a e
               ;; ..other commands here
                ("p" . "Projects")
                ("po" "Office Projects"
                 ((tags "project+@office|@office+LEVEL=2+TODO=\"TODO\""
                        (;; (org-agenda-files (nc/org-projects-file))
                         ;; (org-agenda-prefix-format " %-20c %l%e%l %27:(nc--org-agenda-display-title)")

                         (org-agenda-prefix-format "%l%l %:(nc--org-agenda-display-title)")
                         (org-agenda-sorting-strategy '(priority-down))
                         (org-agenda-overriding-header "Office Projects")))))
                ("pp" "My Personal Projects"
                 ((tags "project+personal|personal+LEVEL=2+TODO=\"TODO\""
                        (;; (org-agenda-files (list nc/org-projects-file))
                         ;;(org-agenda-prefix-format " %-20c %l%e%l")
                         (org-agenda-prefix-format "%l%l %:(nc--org-agenda-display-title)")
                         (org-agenda-sorting-strategy '(priority-down))
                         (org-agenda-overriding-header "Personal Projects")
                         ))))
                ))
     #+end_src
*** Recent open loops

 #+begin_src emacs-lisp
 (defun nc/org-agenda-recent-open-loops ()
     (interactive)
     (let ((org-agenda-start-with-log-mode t)
             (org-agenda-use-time-grid nil))
       ;; (fetch-calendar)
       (org-agenda-list nil (org-read-date nil nil "-2d") 4)))
 #+end_src

** Org Clock Configuration

Too many clock entries clutter up a heading.

#+begin_src emacs-lisp
  (use-package org
    :bind (("C-c C-x C-i" . nc/org-clock-in)
           ("C-c C-x C-o" . org-clock-out))
    :config
    (progn
      ;; Insinuate it everywhere
      (org-clock-persistence-insinuate)
      ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
      (setq org-clock-history-length 23
            ;; Resume clocking task on clock-in if the clock is open
            org-clock-in-resume t
            ;; Separate drawers for clocking and logs
            org-drawers '("PROPERTIES" "CLOCK" "LOGBOOK" "RESULTS" "HIDDEN")
            ;; Save clock data and state changes and notes in the LOGBOOK drawer
            org-clock-into-drawer t
            ;; Sometimes I change tasks I'm clocking quickly -
            ;; this removes clocked tasks with 0:00 duration
            org-clock-out-remove-zero-time-clocks t
            ;; Clock out when moving task to a done state
            org-clock-out-when-done t
            ;; Save the running clock and all clock history when exiting Emacs, load it on startup
            org-clock-persist t
            ;; Prompt to resume an active clock
            org-clock-persist-query-resume t
            ;; Enable auto clock resolution for finding open clocks
            org-clock-auto-clock-resolution #'when-no-clock-is-running
            ;; Include current clocking task in clock reports
            org-clock-report-include-clocking-task t)))
#+end_src

Fix timereport indentation

#+begin_src emacs-lisp
(defun nc--org-clocktable-indent-string (level)
  (if (= level 1)
      ""
    (let ((str "\\"))
      (while (> level 2)
        (setq level (1- level)
              str (concat str "_")))
      (concat str "_ "))))

(advice-add 'org-clocktable-indent-string :override #'nc--org-clocktable-indent-string)
#+end_src


** Refiling
Targets include this file and any file contributing to the agenda - up to 2 levels deep
 #+begin_src emacs-lisp
 (setq org-refile-targets (append '((org-default-notes-file :maxlevel . 2))
                                  '((nc/org-default-tasks-file :level . 1)
                                    (nc/org-projects-file :level . 1)
                                    (nc/org-office-file :level . 1)
                                    (nc/org-default-someday-file :level . 0)
                                    (nil :maxlevel . 3)))) ;; current file

 (setq org-blank-before-new-entry nil)
 #+end_src

 Exclude completed tasks from refile targets.

 #+begin_src emacs-lisp
   (defun nc--verify-refile-target ()
     "Exclude todo keywords with a done state from refile targets"
     (not (member (nth 2 (org-heading-components)) org-done-keywords)))

   (setq org-refile-target-verify-function 'nc--verify-refile-target)
 #+end_src


 Listing filenames and headings in targets and do not complete in steps, helm will listing filenames & headings.

 #+begin_src emacs-lisp
 (setq org-refile-use-outline-path 'file)
 (setq org-outline-path-complete-in-steps nil)
 #+end_src

 Allow creating parent nodes

 #+begin_src emacs-lisp
 (setq org-refile-allow-creating-parent-nodes 'confirm)
 #+end_src
** Refiling a subtree to a new file

Adapted from GTD Boxes https://gitlab.com/howardabrams/spacemacs.d/-/blob/master/elisp/boxes-extras.el
Documentation : http://www.howardism.org/Technical/Emacs/getting-more-boxes-done.html


#+begin_src emacs-lisp
  (defun nc--org-subtree-metadata ()
    "Return a list of key aspects of an org-subtree. Includes the
  following: header text, body contents, list of tags, region list
  of the start and end of the subtree."
    (save-excursion
      ;; Jump to the parent header if not already on a header
      (when (not (org-at-heading-p))
        (org-previous-visible-heading 1))

      (let* ((context (org-element-context))
             (attrs   (cl-second context))
             (props   (org-entry-properties)))

        (list :region     (list (plist-get attrs :begin) (plist-get attrs :end))
              :header     (plist-get attrs :raw-value) ; Use :raw-value because :title returns too more stuff
              :tags       (nc--org-get-subtree-tags props)
              :properties (nc--org-get-subtree-properties attrs)
              :body       (nc--org-get-subtree-content attrs)))))

  (defun nc--org-get-subtree-tags (&optional props)
    "Given the properties, PROPS, from a call to
  `org-entry-properties', return a list of tags."
    (unless props
       (setq props (org-entry-properties)))
    (let ((tag-label (if nc--org-get-subtree-tags-inherited "ALLTAGS" "TAGS")))
      (-some->> props
           (assoc tag-label)
           cdr
           substring-no-properties
           (s-split ":")
           (--filter (not (cl-equalp "" it))))))

  (defvar nc--org-get-subtree-tags-inherited t
    "Returns a subtree's tags, and all tags inherited (from tags
    specified in parents headlines or on the file itself). Defaults
    to true.")

  (defun nc--org-get-subtree-properties (attributes)
    "Return a list of tuples of a subtrees properties where the keys are strings."

    (defun symbol-upcase? (sym)
      (let ((case-fold-search nil))
        (string-match-p "^:[A-Z]+$" (symbol-name sym))))

    (defun convert-tuple (tup)
      (let ((key (cl-first tup))
            (val (cl-second tup)))
        (list (substring (symbol-name key) 1) val)))

    (->> attributes
         (-partition 2)                         ; Convert plist to list of tuples
         (--filter (symbol-upcase? (cl-first it))) ; Remove lowercase tuples
         (-map 'convert-tuple)))

  (defun nc--org-get-subtree-content (attributes)
    "Return the contents of the current subtree as a string."
    (let ((header-components '(clock diary-sexp drawer headline inlinetask
                               node-property planning property-drawer section)))

        (goto-char (plist-get attributes :contents-begin))

        ;; Walk down past the properties, etc.
        (while
            (let* ((cntx (org-element-context))
                   (elem (cl-first cntx))
                   (props (cl-second cntx)))
              (when (member elem header-components)
                (goto-char (plist-get props :end)))))

        ;; At this point, we are at the beginning of what we consider
        ;; the contents of the subtree, so we can return part of the buffer:
        (buffer-substring-no-properties (point) (org-end-of-subtree))))

  (defun nc/org-refile-subtree-to-file (dir)
    "Archive the org-mode subtree and create an entry in the
  directory folder specified by DIR. It attempts to move as many of
  the subtree's properties and other features to the new file."
    (interactive "DDestination: ")
    (let* ((props      (nc--org-subtree-metadata))
           (head       (plist-get props :header))
           (body       (plist-get props :body))
           (tags       (plist-get props :tags))
           (properties (plist-get props :properties))
           (area       (plist-get props :region))
           (filename   (nc--org-filename-from-title head))
           (filepath   (format "%s/%s.org" dir filename)))
      (apply #'delete-region area)
      (nc/org-create-org-file filepath head body tags properties)))

  (defun nc/org-create-org-file (filepath header body tags properties)
    "Create a new Org file by FILEPATH. The contents of the file is
  pre-populated with the HEADER, BODY and any associated TAGS."
    (find-file-other-window filepath)
    (nc--org-set-file-property "TITLE" header t)
    (when tags
      (nc--org-set-file-property "FILETAGS" (s-join " " tags)))

    ;; Insert any drawer properties as #+PROPERTY entries:
    (when properties
      (goto-char (point-min))
      (or (re-search-forward "^\s*$" nil t) (point-max))
      (--map (insert (format "#+property: %s %s\n" (cl-first it) (cl-second it))) properties))

    ;; My auto-insert often adds an initial headline for a subtree, and in this
    ;; case, I don't want that... Yeah, this isn't really globally applicable,
    ;; but it shouldn't cause a problem for others.
    (when (re-search-forward "^\\* [0-9]$" nil t)
      (replace-match ""))

    (delete-blank-lines)
    (goto-char (point-max))
    (insert "\n")
    (insert "* " header)
    (insert "\n")
    (insert body))

  (defun nc--org-filename-from-title (title)
    "Creates a useful filename based on a header string, TITLE.
  For instance, given the string:    What's all this then?
       This function will return:    whats-all-this-then"
    (let* ((no-letters (rx (one-or-more (not alphanumeric))))
           (init-try (->> title
                          downcase
                          (replace-regexp-in-string "'" "")
                          (replace-regexp-in-string no-letters "-"))))
      (string-trim init-try "-+" "-+")))

  (defun nc--org-set-file-property (key value &optional spot)
    "Make sure file contains a top-level, file-wide property.
  KEY is something like `TITLE' or `FILETAGS'. This function makes
  sure that the property contains the contents of VALUE, and if the
  file doesn't have the property, it is inserted at either SPOT, or
  if nil,the top of the file."
    (save-excursion
      (goto-char (point-min))
      (let ((case-fold-search t))
        (if (re-search-forward (format "^#\\+%s:\s*\\(.*\\)" key) nil t)
            (replace-match value nil nil nil 1)

          (cond
           ;; if SPOT is a number, go to it:
           ((numberp spot) (goto-char spot))
           ;; If SPOT is not given, jump to first blank line:
           ((null spot) (progn (goto-char (point-min))
                               (re-search-forward "^\s*$" nil t)))
           (t (goto-char (point-min))))

          (insert (format "#+%s: %s\n" (upcase key) value))))))
#+end_src

** Speed commands
 From https://orgmode.org/worg/org-hacks.html
Customize speed-commands :
- N :: Show next entry keeping other entries closed
- P :: Show previous entry keeping previous entries closed
- m :: org-mark-subtree
- ! :: Jump to the end of the current node
  
 #+begin_src emacs-lisp
   (defun nc/org-show-next-heading-tidily ()
     "Show next entry, keeping other entries closed."
     (if (save-excursion (end-of-line) (outline-invisible-p))
         (progn (org-show-entry) (show-children))
       (outline-next-heading)
       (unless (and (bolp) (org-on-heading-p))
         (org-up-heading-safe)
         (hide-subtree)
         (error "Boundary reached"))
       (org-overview)
       (org-reveal t)
       (org-show-entry)
       (show-children)))

   (defun nc/org-show-previous-heading-tidily ()
     "Show previous entry, keeping other entries closed."
     (let ((pos (point)))
       (outline-previous-heading)
       (unless (and (< (point) pos) (bolp) (org-on-heading-p))
         (goto-char pos)
         (hide-subtree)
         (error "Boundary reached"))
       (org-overview)
       (org-reveal t)
       (org-show-entry)
       (show-children)))

   ;; Improve speed command behavior
   (setq org-use-speed-commands
          (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))

   (push '("N" nc/org-show-next-heading-tidily) org-speed-commands)
   (push '("P" nc/org-show-previous-heading-tidily) org-speed-commands)
   (push '("m" org-mark-subtree) org-speed-commands)


   (add-to-list
    'org-speed-commands
    '("!" .
      (progn
        (outline-show-subtree)
        (org-end-of-subtree))))

   (defun nc/org-go-speed ()
     "Goes to the beginning of an element's header, so that you can execute speed commands."
     (interactive)
     (when (equal major-mode 'org-mode)
       (if (org-at-heading-p)
           (beginning-of-line)
         (outline-previous-heading))))

   (bind-key "C-< C-<" 'nc/org-go-speed org-mode-map)

   ;; Useful bindinding to move next item in lists
   (bind-key "C-< C-n" 'org-next-item org-mode-map)
 #+end_src

** Org Structure templates

#+begin_src emacs-lisp
  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
#+end_src
** Export
*** Markdown
#+begin_src emacs-lisp
  (require 'ox-md)
#+end_src
** Babel
*** Babel languages
- Mermaid needs to install =mmdc= : https://github.com/mermaid-js/mermaid-cli

#+begin_src emacs-lisp
  (use-package ob-restclient)
  (use-package ob-mermaid)


  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (mermaid .t)
     (awk .t)
     (python . t)
     (calc . t)
     (js . t)
     (plantuml . t)
     (dot . t)
     (java .t)
     (restclient . t)))

  (setq org-edit-src-content-indentation 0)

  (require 'ob-clojure)
#+end_src

#+RESULTS:

*** Editing source code
 I don't want to get distracted by the same code in the other window, so I want org src to use the current window.

 #+begin_src emacs-lisp
   (setq org-src-window-setup 'current-window)
 #+end_src
*** Evaluate code blocks without prompting
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src
*** Syntax highlight in source blocks
#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src
** My Org Mode Utilities Functions
*** Manipulate hours/minutes in tables
From https://orgmode.org/worg/org-hacks.html#org0d09b33
#+begin_src emacs-lisp
(defun nc--org-time-string-to-seconds (s)
  "Convert a string HH:MM:SS to a number of seconds."
  (cond
   ((and (stringp s)
         (string-match "\\([0-9]+\\):\\([0-9]+\\):\\([0-9]+\\)" s))
    (let ((hour (string-to-number (match-string 1 s)))
          (min (string-to-number (match-string 2 s)))
          (sec (string-to-number (match-string 3 s))))
      (+ (* hour 3600) (* min 60) sec)))
   ((and (stringp s)
         (string-match "\\([0-9]+\\):\\([0-9]+\\)" s))
    (let ((min (string-to-number (match-string 1 s)))
          (sec (string-to-number (match-string 2 s))))
      (+ (* min 60) sec)))
   ((stringp s) (string-to-number s))
   (t s)))

(defun nc--org-time-seconds-to-string (secs)
  "Convert a number of seconds to a time string."
  (cond ((>= secs 3600) (format-seconds "%h:%.2m:%.2s" secs))
        ((>= secs 60) (format-seconds "%m:%.2s" secs))
        (t (format-seconds "%s" secs))))

(defmacro nc/with-time (time-output-p &rest exprs)
  "Evaluate an org-table formula, converting all fields that look
like time data to integer seconds.  If TIME-OUTPUT-P then return
the result as a time value."
  (list
   (if time-output-p 'nc--org-time-seconds-to-string 'identity)
   (cons 'progn
         (mapcar
          (lambda (expr)
            `,(cons (car expr)
                    (mapcar
                     (lambda (el)
                       (if (listp el)
                           (list 'with-time nil el)
                         (nc--org-time-string-to-seconds el)))
                     (cdr expr))))
          `,@exprs))))
#+end_src

*** Attachments folder
I'm not a big fan of =org-attachments= so I prefer to store all my
attachements in a subfolder *assets/buffer-name-sans-extension* that
correspond to current buffer I'm editing.

#+begin_src emacs-lisp
  (defun nc/create-buffer-attachment-directory ()
      "Create assets directory for org mode file"
    (interactive)
    (let ((assets-buffer-dir (file-name-sans-extension (buffer-name) )))
      (f-mkdir "assets" assets-buffer-dir)
      (message "Creation %s folder for current folder" assets-buffer-dir)))
#+end_src

*** Translate capital keywords to lowercase
From : https://github.com/tecosaur/emacs-config/blob/master/config.org#translate-capital-keywords-old-to-lower-case-new

#+begin_src emacs-lisp
  (defun nc/org-syntax-convert-keyword-case-to-lower ()
    "Convert all #+KEYWORDS to #+keywords."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((count 0)
            (case-fold-search nil))
        (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
          (unless (s-matches-p "RESULTS" (match-string 0))
            (replace-match (downcase (match-string 0)) t)
            (setq count (1+ count))))
        (message "Replaced %d occurences" count))))
#+end_src
** Yankpad

[[https://github.com/Kungsgeten/yankpad][Yankpad]] paste snippets from an org-mode file.

#+begin_src emacs-lisp
    (use-package yankpad    
      :init
      (setq yankpad-file (concat org-directory "/templates/yankpad.org"))
      :config
      ;; If you want to complete snippets using company-mode
      ;; (add-to-list 'company-backends 'company-yankpad)
      ;; If you want to expand snippets with hippie-expand
      (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand))
#+end_src
** Org Roam

I try to do a lot of things with =org-roam= :
- taking my notes
- managing my projects (inspired by https://systemcrafters.net/build-a-second-brain-in-emacs/5-org-roam-hacks/)
- ...

#+begin_src emacs-lisp
  (when is-windows
    (add-to-list 'exec-path "C:/tools/sqlite-tools-win32-x86-3410000"))

  ;; From https://baty.net/2022/searching-org-roam-files/
  (defun nc/search-roam ()
    "Run consult-ripgrep on the org roam directory"
    (interactive)
    (consult-ripgrep (concat org-directory "/slipbox") nil))

  (use-package org-roam
    :after org
    :custom
    (org-roam-directory (file-truename (concat org-directory "/slipbox")))
    :init
    (setq org-roam-v2-ack t)
    :bind
    ("C-c o f" . org-roam-node-find)
    ("C-c o r" . org-roam-node-random)
    ("C-c o s" . nc/search-roam)
    ("C-c o p" . nc/org-roam-find-project)
    ("C-c o t" . nc/org-roam-capture-task)
    (:map org-mode-map
          (("C-c o i" . org-roam-node-insert)))
    :config

    (setq org-roam-capture-templates '(("d" "default" plain "%?"
                                        :if-new
                                        (file+head "%<%Y-%m-%d--%H-%M>--${slug}.org"
                                                   "#+title: ${title}\n#+date: %u\n\n")
                                        :unnarrowed t
                                        :immediate-finish t)
                                       ("p" "Project Note" plain
                                        "%?"
                                        :if-new (file+head
                                                 "projects/%<%Y-%m-%d--%H-%M>--project-${slug}.org"
                                                 "#+TITLE: ${title}\n#+DATE: %<%Y-%m-%d>\n#+FILETAGS: project_note\n\n")
                                        :unnarrowed t)))

    ;; Orgnaize org roam notes
    ;; Adapted from https://jethrokuan.github.io/org-roam-guide/
    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (file-name-nondirectory
           (directory-file-name
            (file-name-directory
             (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (error "main")))

    (setq org-roam-node-display-template
          (concat "${type:15} ${title:*} " (propertize "${tags:20}" 'face 'org-tag)))

    ;; Managing Projects from org-roam
  (defun nc/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun nc/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (nc/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun nc/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files
          (append nc/org-agenda-files
                  (nc/org-roam-list-notes-by-tag "project"))))

  ;; Build the agenda list the first time for the session
  (nc/org-roam-refresh-agenda-list)

  (defun nc/update-refile-targets (filename)
    "Update refile targets"
    (add-to-list 'org-refile-targets `(,filename :regexp . "\\(?:\\(?:Meeting\\|Task\\)s\\)")))

  ;; Refresh org-refile-targets 
  (dolist (project-file (nc/org-roam-list-notes-by-tag "project"))
    (nc/update-refile-targets project-file))

  (defun nc/org-roam-project-finalize-hook ()
    "Adds the captured project file to `org-agenda-files' if the
  capture was not aborted."
    ;; Remove the hook since it was added temporarily
    (remove-hook 'org-capture-after-finalize-hook #'nc/org-roam-project-finalize-hook)

    ;; Add project file to the agenda list if the capture was confirmed
    (unless org-note-abort
      (with-current-buffer (org-capture-get :buffer)
        (progn  
         (add-to-list 'org-agenda-files (buffer-file-name))
         (nc/update-refile-targets (buffer-file-name))))))

  (defun nc/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'nc/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (nc/org-roam-filter-by-tag "project")
     nil
     :templates
     '(("p" "project" plain (file "~/notes/templates/newproject.org")
        :if-new (file+head "projects/%<%Y-%m-%d>-${slug}.org"
                           "#+title: ${title}\n#+category: %^{CATEGORY}\n#+filetags: :project:%^{context|@office|personal}:")
        :unnarrowed t))))

  (defun nc/org-roam-capture-task ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'nc/org-roam-project-finalize-hook)

    ;; Capture the new task, creating the project file if necessary
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (nc/org-roam-filter-by-tag "project"))
                       :templates '(("p" "project" plain "** TODO %?"
                                     :if-new (file+head+olp "projects/%<%Y-%m-%d>-${slug}.org"
                                                            "#+title: ${title}\n#+category: %^{CATEGORY}\n#+filetags: :project:"
                                                            ("Tasks"))))))
    ;; this sets up various file handling hooks so your DB remains up to date
  (org-roam-setup))


  ;; Close project

  (defun nc/set-project-end-date ()
    "Set Project Closing Date"
    (goto-char (point-min))
    (or (re-search-forward "^\s*$" nil t) (point-max))
    (insert (format "#+property: ENDDATE %s\n" (format-time-string "[%Y-%m-%d]"))))

  (defun nc/get-project-tags ()
    "Returns project tags"
    (car (alist-get "FILETAGS"
                   (org-collect-keywords '("filetags"))
                   nil
                   nil
                   'string-equal)))

  (defun nc/is-org-roam-project? ()
    "Checks if buffer is an org-roam project buffer"
    (let* ((tags (nc/get-project-tags)))
      (cond
       ((and (s-present? tags)
             (s-contains? ":project:" tags)) t)
       (t nil))))

  (defun nc/complete-project-tags ()
    "Set project to completed tag"
    (let* ((project-tags (nc/get-project-tags))
                 (project-completed-tags (s-replace "project" "completed" project-tags))
                (year (format-time-string "%Y")))
            (org-roam-set-keyword "filetags" (format"%s%s:" project-completed-tags year))))

  (defun nc/close-org-roam-project ()
    "Update tags and date for project buffer"
    (interactive)
    (if (nc/is-org-roam-project?)
        (progn
          (nc/set-project-end-date)
          (nc/complete-project-tags))
      (error "Not an org roam project")))
#+end_src
** Denote

#+begin_src elisp

(use-package denote
  :when (getenv "PIM_HOME")
  :bind
  ("C-c n n" . 'denote)
  ("C-c n f" . 'denote-open-or-create)
  ("C-c n k" . 'denote-rename-file-keywords )    ;; update file name automatically
  ("C-c n u" . 'denote-rename-file-using-front-matter)
  ("C-c n l" . 'denote-link-find-backlink)

  (:map dired-mode-map
        ("C-c C-d C-i" . 'denote-link-dired-marked-notes)                        
        ("C-c C-d C-r" . 'denote-dired-rename-files)                           
        ("C-c C-d C-k" . 'denote-dired-rename-marked-files-with-keywords)      
        ("C-c C-d C-R" . 'denote-dired-rename-marked-files-using-front-matter))
  
  :init
  (setq denote-directory (expand-file-name "notes" (getenv "PIM_HOME")))
  :config
  
  (setq denote-prompts '(subdirectory title keyword))
  (setq denote-infer-keywords t)
  (setq denote-sort-keywords t)
  (setq denote-excluded-directories-regexp "attachments")

  ;; Makes the denote links different from usual link.
  (set-face-attribute 'denote-faces-link
                      nil :foreground "magenta" :inherit 'link)

  ;; Remove the date and the identifier. They are duplicated with the file name.
  ;; I want to remove filetags too but denote-keyword-* need that.
  ;;(setq denote-org-front-matter "#+title: %1$s\n#+filetags: %3$s\n")

  (add-hook 'dired-mode-hook #'denote-dired-mode))


#+end_src
** Consult Notes

#+begin_src emacs-lisp
  (use-package consult-notes
    :straight (:type git :host github :repo "mclear-tools/consult-notes")
    :commands (consult-notes
               consult-notes-search-in-all-notes
               ;; if using org-roam 
               ;;consult-notes-org-roam-find-node
               ;;consult-notes-org-roam-find-node-relation
               )
    :config
    ;;(setq consult-notes-file-dir-sources '(("Name"  ?key  "path/to/dir"))) ;; Set notes dir(s), see below
    
    ;; Set org-roam integration, denote integration, or org-heading integration e.g.:
    (setq consult-notes-org-headings-files '("~/notes/"))
    (consult-notes-org-headings-mode)
    (when (locate-library "denote")
      (consult-notes-denote-mode)
      (setq consult-notes-denote-display-id nil))
    ;; search only for text files in denote dir
    (setq consult-notes-denote-files-function (lambda () (denote-directory-files nil t t)))
    :bind
      (("C-c n F" . consult-notes)
       ("C-c n s" . consult-notes-search-in-all-notes)))
#+end_src

* Programming
:properties:
:header-args+: :tangle "./lisp/setup-programming.el"
:end:

Programming configuration module automatically tangled in =./lisp/setup-programming.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-programming.el --- Programming configuration module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src
** Compile
Better defaults

#+begin_src emacs-lisp
(use-package compile
  :defer t
  :hook ((compilation-filter . ansi-color-compilation-filter))
  :config
  (setopt compilation-scroll-output t)
  (setopt compilation-ask-about-save nil)
  (require 'ansi-color))
#+end_src
** LSP Mode
:PROPERTIES:
:ID:       96b7778d-9937-4f70-a66a-55d249061c3f
:END:

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands lsp
  :bind
  (:map lsp-mode-map
        ( ;;("C-\M-b" . lsp-find-implementation)
         ("M-RET" . lsp-execute-code-action)))
  :bind-keymap ("C-c l" . lsp-command-map)
  :hook (lsp-mode . lsp-enable-which-key-integration)
  :config
  (setq ; recommended
   gc-cons-threshold (* 100 1024 1024)
   read-process-output-max (* 1024 1024))
  
  (setq ; optional
   ;; lsp-clojure-custom-server-command '("/Users/nchapon/_PIM/tmp/2del/clojure-lsp") 

                                        ; Features
   lsp-lens-enable t
                                        ;lsp-semantic-tokens-enable t

   lsp-headerline-breadcrumb-enable nil ;; disable breadcrumb

   lsp-completion-provider :none

   ;; Conflicts with other Clojure emacs packages
   cljr-add-ns-to-blank-clj-files nil ; disable clj-refactor adding ns to blank files
   cider-eldoc-display-for-symbol-at-point nil ; disable cider eldoc integration
                                        ; lsp-eldoc-enable-hover nil ; disable lsp-mode showing eldoc during symbol at point
                                        ; lsp-enable-indentation nil ; uncomment to use cider indentation instead of lsp
                                        ; lsp-enable-completion-at-point nil ; uncomment to use cider completion instead of lsp

   ;; Terraform
   lsp-disabled-clients '(tfls)

   ))



;; optionally
(use-package lsp-ui
  :hook lsp-mode
  :init
  ;; (setq lsp-ui-doc-alignment 'frame
  ;;       lsp-ui-doc-position  'bottom
  ;;       lsp-ui-doc-use-childframe nil)
  :config

  (setq lsp-ui-imenu-window-fix-width 40)
  ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
  ;; @see https://github.com/emacs-lsp/lsp-ui/issues/243
  (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate)
    (setq mode-line-format nil))
  :bind (:map lsp-ui-mode-map
              (([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
               ([remap xref-find-references] . lsp-ui-peek-find-references))))

(use-package lsp-treemacs
  :commands lsp-treemacs-errors-list)


;; Integration with consult
(use-package consult-lsp)

(with-eval-after-load 'lsp-mode
  ;; Remap `lsp-treemacs-errors-list' (bound to C-c l g e).
  (define-key lsp-mode-map
              [remap lsp-treemacs-errors-list]
              #'consult-lsp-diagnostics)

  ;; Remap `xref-find-apropos' (bound to C-c l g a).
  (define-key lsp-mode-map
              [remap xref-find-apropos]
              #'consult-lsp-symbols))


#+end_src

This function adds the hooks that will enable LSP-powered formatting
and import organizing when saving a file with code.

#+begin_src elisp
  (defun lsp-save-hooks () "Install save hooks for lsp."
         (add-hook 'before-save-hook #'lsp-format-buffer t t)
         (add-hook 'before-save-hook #'lsp-organize-imports t t))
#+end_src

Hydra

#+begin_src emacs-lisp
(defhydra hydra-lsp (:exit t :hint nil)
    "
   Buffer^^               Server^^                   Symbol
  -------------------------------------------------------------------------------------
   [_f_] format           [_M-r_] restart            [_d_] definition   [_i_] implementation  [_o_] documentation
   [_m_] imenu            [_S_]   shutdown           [_D_] declaration  [_t_] type            [_r_] rename
   [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature"
    ("d" lsp-ui-peek-find-definitions)
    ("D" lsp-find-declaration)
    ("R" lsp-ui-peek-find-references)
    ("i" lsp-ui-peek-find-implementation)
    ("t" lsp-find-type-definition)
    ("s" lsp-signature-help)
    ("o" lsp-describe-thing-at-point)
    ("r" lsp-rename)

    ("f" lsp-format-buffer)
    ("m" lsp-ui-imenu)
    ("x" lsp-execute-code-action)

    ("M-s" lsp-describe-session)
    ("M-r" lsp-restart-workspace)
    ("S" lsp-shutdown-workspace))
(global-set-key (kbd "C-l") 'hydra-lsp/body)

#+end_src

*** Flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :hook ((lsp-mode . flycheck-mode))
    :init
    (setq flycheck-indication-mode 'right-fringe)
    ;; only check on save
    (setq flycheck-check-syntax-automatically '(mode-enabled save)))
#+end_src
*** Dap

#+begin_src emacs-lisp
  (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)
    :commands dap-debug
    :config
    (require 'dap-hydra)

    ;; Bind `C-c l d` to `dap-hydra` for easy access
     


    )
#+end_src
** Treesitter

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (use-package treesit
    :straight (:type built-in)
    :mode ("\\.tsx\\'" . tsx-ts-mode)
    :config
    (setq treesit-language-source-alist
          '((bash "https://github.com/tree-sitter/tree-sitter-bash")
            (cmake "https://github.com/uyha/tree-sitter-cmake")
            (css "https://github.com/tree-sitter/tree-sitter-css")
            (elisp "https://github.com/Wilfred/tree-sitter-elisp")
            (go "https://github.com/tree-sitter/tree-sitter-go")
            (html "https://github.com/tree-sitter/tree-sitter-html")
            (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
            (json "https://github.com/tree-sitter/tree-sitter-json")
            (make "https://github.com/alemuller/tree-sitter-make")
            (markdown "https://github.com/ikatyang/tree-sitter-markdown")
            (python "https://github.com/tree-sitter/tree-sitter-python")
            (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
            (rust "https://github.com/tree-sitter/tree-sitter-rust")
            (toml "https://github.com/tree-sitter/tree-sitter-toml")
            (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "tsx/src")
            (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "typescript/src")
            (yaml "https://github.com/ikatyang/tree-sitter-yaml")
            (astro "https://github.com/virchau13/tree-sitter-astro")
            (sql "https://github.com/DerekStride/tree-sitter-sql" "gh-pages" "src")
            (hcl "https://github.com/tree-sitter-grammars/tree-sitter-hcl")))

    (defun treesit-install-all-grammars ()
      (interactive)
      (dolist (lang (mapcar #'car treesit-language-source-alist))
        (treesit-install-language-grammar lang)))

    (defvar treesit-langs-mode-overrides '((sh-mode . bash)
                                           (sh-ts-mode . bash)
                                           (css-mode . css)
                                           (emacs-lisp-mode . elisp)
                                           (emacs-lisp-ts-mode . elisp)
                                           (js-mode . javascript)
                                           (js-ts-mode . javascript)
                                           (json-mode . json)
                                           (makefile-mode . make)
                                           (makefile-ts-mode . make)))

    (defun treesit-parse-lang-from-mode (mode)
      (let* ((mode (if (symbolp mode) (symbol-name mode) mode))
             (lang (save-match-data
                     (string-match "\\(.*?\\)\\(-ts\\)?-mode" mode)
                     (match-string 1 mode))))
        (intern lang)))

    (defun treesit-lang-for-mode (mode)
      (or (cdr (assoc mode treesit-langs-mode-overrides))
          (treesit-parse-lang-from-mode mode)
          (error "Unable to determine tree-sitter parser for %s" mode)))

    (defun treesit-parser ()
      (if-let ((lang (treesit-lang-for-mode major-mode)))
          (treesit-parser-create lang (current-buffer))
        (user-error "No tree-sitter parser for %s" major-mode)))

    (defun treesit-node-start-line-number (node)
      (when-let ((start (treesit-node-start node)))
        (line-number-at-pos start)))

    (defun treesit-surrounding-method-call-named (name)
      (treesit-parent-until
       (treesit-node-at (point) (treesit-parser))
       (lambda (n)
         (and
          (equal (treesit-node-type n) "call")
          (equal
           (treesit-node-text
            (treesit-node-child-by-field-name n "method"))
           name)))
       t))

    (defun treesit-rspec-all-calls-named (type)
      (let* ((parser (treesit-parser))
             (root (treesit-parser-root-node parser)))
        (->> (treesit-query-capture
              root
              `((call
                 method: (identifier) @id
                 (:equal @id ,type)
                 arguments: (argument_list (string (string_content)))
                 block: (_)) @node))
             (-filter (lambda (n) (eq (car n) 'node)))
             (-map #'cdr))))

    (defun treesit-rspec-all-examples ()
      (treesit-rspec-all-calls-named "it"))

    (defun treesit-rspec-all-example-groups ()
      (treesit-rspec-all-calls-named "describe"))

    (defun treesit-rspec-all-contexts ()
      (treesit-rspec-all-calls-named "context"))

    (defun treesit-rspec-example-at-point ()
      (treesit-surrounding-method-call-named "it"))

    (defun treesit-rspec-context-at-point ()
      (treesit-surrounding-method-call-named "context"))

    (defun treesit-rspec-example-group-at-point ()
      (treesit-surrounding-method-call-named "describe"))

    (defun treesit-rspec-method-name (node)
      (when-let ((args (treesit-node-child-by-field-name node "arguments")))
        (->> (treesit-query-capture args '((string (string_content) @name)))
             (-filter (lambda (n) (eq (car n) 'name)))
             (-map #'cdr)
             (-mapcat (lambda (n) (treesit-node-text n t)))))))

#+end_src

** Parenthesis
*** Smart Parens
Smart parens for all programming modes with paredit bindings.

#+begin_src emacs-lisp
  (use-package smartparens
    :defer t
    :diminish ""
    :hook (((clojure-mode
             emacs-lisp-mode
             common-lisp-mode
             scheme-mode
             lisp-mode
             cider-repl-mode
             inferior-lisp-mode
             inferior-emacs-lisp-mode)
            . smartparens-strict-mode)
           (prog-mode . smartparens-mode))

    :bind (:map smartparens-mode-map
                ("C-M-q" . sp-indent-defun)
                :map smartparens-strict-mode-map
                (";" . sp-comment))

    :config
    (require 'smartparens-config)
    (sp-use-paredit-bindings)
    ;; Unbind sp-convolute-xexp (conflict with xref-find-references / lsp-ui-peek-find-references)
    (unbind-key "M-?" smartparens-mode-map)

    (define-key smartparens-mode-map (kbd "M-r") 'sp-rewrap-sexp) ; needs to be set manually, because :bind section runs before config
    (setq smartparens-strict-mode t)
    (sp-local-pair 'emacs-lisp-mode "`" nil :when '(sp-in-string-p))

    (defun nc--create-newline-and-enter-sexp (&rest _ignored)
      "Open a new brace or bracket expression, with relevant newlines and indent. "
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))

    (sp-with-modes '(c-mode c++-mode js-mode js2-mode java-mode
                            typescript-mode perl-mode)
      (sp-local-pair "{" nil :post-handlers
                     '((nc--create-newline-and-enter-sexp "RET")))))


#+end_src

*** Show Paren Mode
Emacs builtin show paren mode.
#+begin_src emacs-lisp
  (use-package paren
    :straight nil
    :hook (prog-mode . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-when-point-in-periphery t))
#+end_src
** DevDocs

#+begin_src emacs-lisp
  (use-package devdocs
    :bind ("C-h D" . devdocs-lookup))
#+end_src

** Clojure
*** clojure-mode
#+begin_src emacs-lisp
  (use-package clojure-mode
    :hook
    ((clojure-mode . lsp)
     (clojurec-mode . lsp)
     (clojurescript-mode . lsp)
     (clojure-mode . lsp-save-hooks))
    :init
    (setq clojure-align-forms-automatically t))
#+end_src
*** Cider
My custom rebinding =C-c C-p= to =cider-pprint-eval-last-sexp-to-comment=
#+begin_src emacs-lisp
  (use-package cider
    :init
    (setq org-babel-clojure-backend 'cider)
    :bind ([remap cider-pprint-eval-last-sexp] . cider-pprint-eval-last-sexp-to-comment))
#+end_src

** Docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile.*\\'")
#+end_src
** Go
#+begin_src emacs-lisp
  (use-package go-mode)
#+end_src
** Just
Mode for justfiles used by [[https://github.com/casey/just][Just]] 
#+begin_src emacs-lisp
  (use-package just-mode)
#+end_src
** Lua
#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua\\'")
#+end_src
** Markdown

GitHub Flavored Markdown by default for README.md files.

- Using Pandoc to export to HTML
- Rendering Markdown with GitHub API

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'"       . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config

    (setq markdown-live-preview-delete-export 'delete-on-destroy)
    (setq markdown-fontify-code-blocks-natively t)
    (setq markdown-split-window-direction 'right)
    ;; Process Markdown with Pandoc, using GitHub stylesheet for nice output
    (let ((stylesheet (expand-file-name
                       (locate-user-emacs-file "etc/pandoc.css"))))
      (setq markdown-command
            (concat "pandoc --toc --section-divs"
                    " --css   file://" stylesheet
                    " --standalone -f markdown -t html5"
                       )))
    )

  (use-package markdown-toc
    :after markdown-mode)

  ;; From https://www.jamescherti.com/emacs-markdown-table-of-contents-update-before-save/
  ;; The following functions and hooks guarantee that any existing table of
  ;; contents remains current whenever changes are made to the markdown file,
  ;; while also ensuring that both the window start and cursor position remain
  ;; unchanged.
  (defun nc/markdown-toc-gen-if-present ()
    "Generate a table of contents if it is already present."
    (let ((marker (point-marker))
          (current-visual-line
           (save-excursion
             (beginning-of-visual-line)
             (count-screen-lines (window-start) (point)))))
      (unwind-protect
          (when (markdown-toc--toc-already-present-p)
            (markdown-toc-generate-toc))
        (progn
          (goto-char (marker-position marker))
          (when (> current-visual-line 0)
            (let ((window-start (save-excursion
                                  (beginning-of-visual-line)
                                  (let ((line-move-visual t)
                                        (line-move-ignore-invisible nil))
                                    (line-move (* -1 current-visual-line)))
                                  (beginning-of-visual-line)
                                  (point))))
              (set-window-start (selected-window) window-start)))))))

  (defun nc/setup-markdown-toc ()
    "Setup the markdown-toc package."
    (add-hook 'before-save-hook #'nc/markdown-toc-gen-if-present nil t))

  (add-hook 'markdown-mode-hook #'nc/setup-markdown-toc)
  ;; (add-hook 'markdown-ts-mode-hook #'my-setup-markdown-toc)
  ;; (add-hook 'gfm-mode-hook #'my-setup-markdown-toc)


  ;; Render Markdwon with GitHub API
  (use-package gh-md
    :after markdown-mode
    :bind 
    (:map markdown-mode-map
          ([remap markdown-preview] . gh-md-render-buffer)))

#+end_src
** Plant UML

Needs Java and plantuml.jar installed in =~/opt=

#+begin_src shell :tangle no  
  mkdir -P ~/opt
  cd ~/opt
  curl -O -J -L https://github.com/plantuml/plantuml/releases/download/v1.2024.6/plantuml-1.2024.6.jar
  chmod 755 plantuml.jar
#+end_src

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :init
    (setq plantuml-default-exec-mode 'jar)
    (setq plantuml-jar-path (expand-file-name "~/opt/plantuml.jar"))
    (setq org-plantuml-jar-path (expand-file-name "~/opt/plantuml.jar"))
    ;; (setq org-startup-with-inline-images t)
    ;; (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    ;; (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
    :mode "\\.puml\\'"
    :bind
    (:map plantuml-mode-map
          ("C-c C-p" . nc/plantuml-generate-png))
    :config
    (setq plantuml-output-type "png")
    (defun nc/plantuml-generate-png ()
      (interactive)
      (when (buffer-modified-p)
        (error "There are unsaved changes!!!"))
      (let* ((input (expand-file-name (buffer-file-name)))
             (output (concat (file-name-sans-extension input) ".png"))
             (output-buffer (get-file-buffer output)))
        (message (format "Rendering %s" input))
        (call-process "java" nil t nil
                      ;; the jar file...
                      "-jar"
                      (expand-file-name plantuml-jar-path)
                      "-charset" "UTF-8"
                      input
                      "-tpng")
        (if output-buffer
            (with-current-buffer output-buffer
              (revert-buffer-quick)
              (pop-to-buffer output-buffer))
          (find-file-other-window output)))))
#+end_src
** Python
*** python-mode
:PROPERTIES:
:ID:       02349703-0f5e-4e81-a82f-08be2189690f
:END:
#+begin_src emacs-lisp
  (use-package python-mode
    :straight nil
    :mode ("\\.py\\'")
    :hook ((python-mode . dap-ui-mode)
           (python-mode . dap-mode)
           (python-mode . lsp-deferred))
    :custom
    (python-shell-interpreter "python3")


    :config
    (require 'dap-python)
    (setq dap-python-debugger 'debugpy))

#+end_src
*** lsp-pyright
:warning: LSP pyright needs NPM
#+begin_src emacs-lisp
(use-package lsp-pyright
  :init
  (setq lsp-pyright-typechecking-mode "basic") ;; too much noise in "real" projects
  :hook (python-mode . (lambda ()
                         (require 'lsp-pyright)
                         (lsp-deferred))))
#+end_src
*** Conda

#+begin_src emacs-lisp
  (use-package conda
    :when (executable-find "conda")
    :config
    (conda-env-initialize-interactive-shells)
    (conda-env-initialize-eshell)
    (add-to-list
       'global-mode-string
       '(:eval
         (list
          (if conda-env-current-name
              (propertize (concat "(py: " conda-env-current-name ") ")
                          'face 'font-lock-builtin-face
                          'help-echo "Conda environment"
                          'mouse-face '(:box 1)
                          'local-map (make-mode-line-mouse-map
                                      'mouse-1
                                      (lambda () (interactive)
                                        (conda-env-activate))))
            "")))))
#+end_src
*** Virtualenvwrapper

#+begin_src emacs-lisp
(use-package virtualenvwrapper
  :ensure t
  :init
  (venv-initialize-eshell))
#+end_src

*** Pyvenv

#+begin_src emacs-lisp
  (use-package pyvenv
    :config
    (pyvenv-mode))


  (defun pyvenv-activate-poetry ()
    "Activate the venv created by Poetry."
    (interactive)
    (let ((default-directory (project-root (project-current)))
          (path (string-trim
                 (shell-command-to-string "env -u VIRTUAL_ENV poetry env info --path"))))
      (pyvenv-activate path)
      (message "project: %s\nactivated: %s" default-directory path)))
#+end_src

*** Apheleia

Automatic formatting with ruff when saving 

#+begin_src emacs-lisp
  (use-package apheleia
    :config
    (add-to-list 'apheleia-mode-alist '(python-mode . ruff))
    :bind
    (("C-c f" . apheleia-format-buffer)))


#+end_src
*** Python pytest

#+begin_src emacs-lisp
  (use-package python-pytest
    :straight '(python-pytest :host github :repo "nchapon/emacs-python-pytest")
    :config
    (setq python-pytest-executable "python -m pytest")
    :bind
    (:map python-mode-map
            ("C-c C-t a" . python-pytest)
            ([remap python-skeleton-try] . python-pytest-function-dwim)
            ("C-c C-t T" . python-pytest-function)
            ([remap python-skeleton-for] . python-pytest-file-dwim)
            ("C-c C-t F" . python-pytest-file)
            ([remap python-skeleton-def] . python-pytest-dispatch)
            ("C-c C-t r" . python-pytest-repeat)
            ("C-c C-t x" . python-pytest-last-failed)))
#+end_src

** Terraform

Needs Terraform LSP Server, not the latest version, works fine with =0.28.1=

#+begin_src shell :tangle no
    asdf plugin add terraform-ls
  asdf install terraform-ls 0.28.1
  asdf global terraform-ls 0.28.1
#+end_src

#+begin_src emacs-lisp
  (use-package terraform-mode
    :hook ((terraform-mode . lsp)))
#+end_src

** Rest Client

Verb is a package for Emacs which allows you to organize and send HTTP requests

ℹ️ To replace =restlient= wich is no longer maintained

#+begin_src emacs-lisp
  (use-package verb
    :config
    (setq verb-auto-kill-response-buffers nil) ; Response buffers killed before sending a request.

    )

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-c C-r") verb-command-map))

#+end_src
** Web
*** Web Mode
[[https://web-mode.org/][Web Mode]] major mode for editing HTML pages

#+begin_src emacs-lisp
  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.hbs\\'" . web-mode)
           ("\\.tag$" . web-mode)
           ("\\.ftl$" . web-mode)
           ("\\.jsp$" . web-mode)
           ("\\.vue$" . web-mode)
           ("\\.php$" . web-mode))
    :config
    (add-hook 'web-mode-hook (lambda ()
                               (setq web-mode-markup-indent-offset 4)
                               (setq web-mode-code-indent-offset 4))))

#+end_src

*** Javascript
[[https://github.com/mooz/js2-mode][JS2 mode]] improved javascript editing mode
#+begin_src emacs-lisp
(use-package js2-mode
  :mode "\\.js\\'"
  :init
  (defalias 'javascript-generic-mode 'js2-mode)
  :config
  (js2-imenu-extras-setup)
  (setq-default js-auto-indent-flag nil
                js2-strict-missing-semi-warning nil
                js-indent-level 2)

  ;; Don't override global M-j keybinding (join lines)
  (define-key js2-mode-map (kbd "M-j") nil))

#+end_src


** YAML

#+begin_src emacs-lisp
  (use-package yaml-ts-mode
    :mode ("\\.yaml\\'" "\\.yml\\'")
    :config
    (add-hook 'yaml-ts-mode-hook #'highlight-indent-guides-mode))

  (use-package yaml-pro
    :hook (yaml-ts-mode . yaml-pro-ts-mode)
    :config
    (defun yaml-pro-edit-initialize-buffer-filter-args-advice (args)
      (if-let ((mode (language-detection-detect-mode (buffer-string))))
          (cl-destructuring-bind (parent-buffer buffer initial-text type initialize path) args
            (let ((init-func (lambda ()
                               (funcall mode)
                               (when initialize
                                 (call-interactively initialize)))))
              (list parent-buffer buffer initial-text type init-func path)))
        args))
    (advice-add 'yaml-pro-edit-initialize-buffer :filter-args #'yaml-pro-edit-initialize-buffer-filter-args-advice)

    :bind
      (:map yaml-pro-ts-mode-map
            ("C-c j" . yaml-pro-ts-move-subtree-down)
            ("C-c k" . yaml-pro-ts-move-subtree-up)
            ("C-c f" . yaml-pro-format)))
#+end_src
* Shell
:properties:
:header-args+: :tangle "./lisp/setup-shell.el"
:end:

Shell configuration module automatically tangled in =./lisp/setup-shell.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-shell.el --- Shell configuration module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src


** vterm 

Last emacs terminal emulator :  https://github.com/akermu/emacs-libvterm

[[https://github.com/jixiuf/vterm-toggle][vterm-toggle]] toggles between the Vterm buffer and the current editing buffer 

#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm
    :unless is-windows
    :custom
    (vterm-disable-bold-font t)
    (vterm-disable-inverse-video nil)
    (vterm-disable-underline nil)
    (vterm-kill-buffer-on-exit t)
    (vterm-max-scrollback 9999)
    (vterm-shell "/bin/zsh")
    (vterm-term-environment-variable "xterm-256color"))

  (use-package vterm-toggle
    :custom
    ;; Show Vterm Buffer in bottom side
    (vterm-toggle-fullscreen-p nil)
    :unless is-windows
    :config
    (add-to-list 'display-buffer-alist
       '("\*vterm\*"
         (display-buffer-in-side-window)
         (window-height . 0.3)
         (side . bottom)
         (slot . 0)))

    :bind
    ("C-c s" . vterm-toggle)
    (:map vterm-mode-map
          ("C-<return>" . vterm-toggle-insert-cd)
          ("C-S-n" . vterm-toggle-forward)
          ("C-S-p" . vterm-toggle-backward)
          ))
#+end_src

** Eshell

Adapted from https://config.daviwil.com/emacs#eshell 

#+begin_src emacs-lisp
  (defun nc/map-line-to-status-char (line)
    (cond ((string-match "^?\\? " line) "?")))

  (defun nc/get-git-status-prompt ()
    (let ((status-lines (cdr (process-lines "git" "status" "--porcelain" "-b"))))
      (seq-uniq (seq-filter 'identity (mapcar 'nc/map-line-to-status-char status-lines)))))

  (defun nc/get-prompt-path ()
    (let* ((current-path (eshell/pwd))
           (git-output (shell-command-to-string "git rev-parse --show-toplevel"))
           (has-path (not (string-match "^fatal" git-output))))
      (if (not has-path)
        (abbreviate-file-name current-path)
        (string-remove-prefix (file-name-directory git-output) current-path))))

  ;; This prompt function mostly replicates my custom zsh prompt setup
  ;; that is powered by github.com/denysdovhan/spaceship-prompt.
  (defun nc/eshell-prompt ()
    (let ((current-branch (magit-get-current-branch))
          )
      (concat
       "\n"
       (propertize (system-name) 'face `(:foreground "#62aeed"))
       (propertize " > " 'face `(:foreground "white"))
       (propertize (nc/get-prompt-path) 'face `(:foreground "#82cfd3"))
       (when current-branch
         (concat
          (propertize " • " 'face `(:foreground "white"))
          (propertize (concat " " current-branch) 'face `(:foreground "#c475f0"))))

       (propertize " • " 'face `(:foreground "white"))
       (propertize (format-time-string "%I:%M:%S %p") 'face `(:foreground "#5a5b7f"))
       (if (= (user-uid) 0)
           (propertize "\n#" 'face `(:foreground "red2"))
         (propertize "\nλ" 'face `(:foreground "#aece4a")))
       (propertize " " 'face `(:foreground "white")))))

  (defun nc/eshell-configure ()

    (use-package xterm-color)

    (push 'eshell-tramp eshell-modules-list)
    (push 'xterm-color-filter eshell-preoutput-filter-functions)
    (delq 'eshell-handle-ansi-color eshell-output-filter-functions)

    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    (add-hook 'eshell-before-prompt-hook
              (lambda ()
                (setq xterm-color-preserve-properties t)))

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; We want to use xterm-256color when running interactive commands
    ;; in eshell but not during other times when we might be launching
    ;; a shell command to gather its output.
    (add-hook 'eshell-pre-command-hook
              (lambda () (setenv "TERM" "xterm-256color")))
    (add-hook 'eshell-post-command-hook
              (lambda () (setenv "TERM" "dumb")))

    ;; Use completion-at-point to provide completions in eshell
    (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)
    (define-key eshell-mode-map (kbd "C-r") 'consult-history)

    ;; Visual Commands
    (require 'em-term)
    (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                                   "ncftp" "pine" "tin" "trn" "elm" "htop" "node" "npm")
          eshell-visual-subcommands '(("git" "log" "diff" "show")))

    ;; Initialize the shell history
    (eshell-hist-initialize)

    (setenv "PAGER" "cat")

    (setq eshell-prompt-function      'nc/eshell-prompt
          eshell-prompt-regexp        "^λ "
          eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-highlight-prompt t
          eshell-scroll-to-bottom-on-input t
          eshell-prefer-lisp-functions nil))

  (use-package eshell
    :after esh-mode
    :hook (eshell-first-time-mode . nc/eshell-configure)

    :config

    (defun nc/eshell-clear-buffer ()
      "Clear terminal"
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)))


    (defun nc/eshell-quit-or-delete-char (arg)
      (interactive "p")
      (if (and (eolp) (looking-back eshell-prompt-regexp))
          (progn
            (eshell-life-is-too-much) ; Why not? (eshell/exit)
            (ignore-errors
              (delete-window)))
        (delete-forward-char arg)))

    :bind
    (:map eshell-mode-map
          ("C-d" . nc/eshell-quit-or-delete-char)
          ("C-l" . nc/eshell-clear-buffer))

    )

  (add-hook 'eshell-mode-hook (lambda () (setenv "TERM" "xterm-256color")))
#+end_src


*** eshell-toggle


#+begin_src emacs-lisp
  (use-package eshell-toggle
    :custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-use-projectile-root t)
    (eshell-toggle-run-command nil)
    :bind ("C-c e" . eshell-toggle))
#+end_src
** TODO dwim-shell-command

FIX : Path to plantuml ??

#+begin_src emacs-lisp
  (use-package dwim-shell-command
    :demand t ;; forces package loading
    :bind (([remap shell-command] . dwim-shell-command)
           :map dired-mode-map
           ([remap dired-do-async-shell-command] . dwim-shell-command)
           ([remap dired-do-shell-command] . dwim-shell-command)
           ([remap dired-smart-shell-command] . dwim-shell-command))
    :config
    (defun nc/dwim-shell-command-plantuml-to-png ()
      "Render plantuml file into PNG"
      (interactive)
      (dwim-shell-command-on-marked-files
       "Render to puml"
       "plantuml.bat '<<f>>'"
       :extensions "puml"
       :utils "java"
       :on-completion
       (lambda (buffer _process)
         (with-current-buffer buffer
           (save-excursion
             (goto-char 0)
             (when (re-search-forward "output='\\(.*\\)'" nil t)
                 (find-file-other-window (match-string-no-properties 1))
                 (kill-buffer buffer)
               )))))
      )
     (bind-key "C-c C-! e" #'nc/dwim-shell-command-plantuml-to-png)
     (defun nc/dwim-run-pytest ()
      "Run pytest on marked file"
      (interactive)
      (dwim-shell-command-on-marked-files
       "Run pytest"
       "pytest --color=yes -k <<f>>"
       :extensions "py"
       :utils "pytest"
       :error-autofocus t
       :silent-success t
       )
      )
     (bind-key "C-c C-! t" #'nc/dwim-run-pytest 'python-mode-map)
     
    )
#+end_src


* Custom Functions
:properties:
:header-args+: :tangle "./lisp/setup-functions.el"
:end:

Custom functions module automatically tangled in =./lisp/setup-functions.el=
#+begin_src emacs-lisp :noweb yes
  ;;; setup-functions.el --- Custom functions module -*- lexical-binding: t; buffer-read-only: t; no-byte-compile: t -*-

  <<nc-header>>
#+end_src

** Emacs Config File

 #+begin_src emacs-lisp
   (defun nc/goto-emacs-config ()
       "Edit Readme.org"
       (interactive)
       (find-file "~/.emacs.d/Readme.org"))     
 #+end_src

** My personal credentials

#+begin_src emacs-lisp
    (defun nc/goto-my-credentials ()
      "Goto my credentials"
      (interactive)
      ;; before disable super-save-mode
      ;;(super-save-stop)
      (find-file (concat nc/org-default-personal-dir "/password.gpg")))
#+end_src


** Pseudo uuid

Generate a 32 random pseudo uuid

#+begin_src emacs-lisp
  (defun nc--random-alnum ()
    (let* ((alnum "abcdef0123456789")
           (i (% (abs (random)) (length alnum))))
      (substring alnum i (1+ i))))

  (defun nc/uuid ()
    "Generate a pseudo UUID"
    (interactive)
    (dotimes (i 32) (insert (nc--random-alnum))))
#+end_src


** Password generator
Generates a strong password

 #+begin_src emacs-lisp
   (defun nc--random-char ()
       (let* ((alnum "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-/%+*?&#[]()={}_<>!$,;:^µ0123456789")
              (i (% (abs (random)) (length alnum))))
         (substring alnum i (1+ i))))


   (defun nc/generate-password ()
       "Generates a strong password"
       (interactive)
       (dotimes (i 12) (insert (nc--random-char))))
 #+end_src

** TimeSlot
Insert time slot mainly used when I schedule meeting or appointment.
#+begin_src emacs-lisp
  (defvar current-hour-format "%H:00")

  (defun nc/insert-time-slot ()
    "Insert Time Slot"
    (interactive)
    (let ((begin (format-time-string current-hour-format (current-time)))
          (end (format-time-string current-hour-format (time-add (current-time) (seconds-to-time 3600)))))
      (insert (concat begin "-" end))))
#+end_src

** Inserting time stamps
   From : https://github.com/novoid/dot-emacs/blob/master/config.org#inserting-time-stamps--my-map-ddtt

#+begin_src emacs-lisp
  (defun nc/insert-datestamp ()
    "Insert the current date in yyyy-mm-dd format."
    (interactive "*")
    (if (eq major-mode 'org-mode)
        (progn
          (org-insert-time-stamp nil nil nil)
          (insert " "))
        (insert (format-time-string "%Y-%m-%d" (current-time)))))
 #+end_src


 #+begin_src emacs-lisp
   (defun nc/insert-datestamp-inactive ()
     "Insert the current date in yyyy-mm-dd format."
     (interactive "*")
     (if (eq major-mode 'org-mode)
         (progn
       (org-insert-time-stamp nil nil t)
       (insert " "))
       (insert (format-time-string "%Y-%m-%d" (current-time)))))
 #+end_src

** Searching in my notes

#+begin_src emacs-lisp
  (defun nc/search-notes ()
    "Search in all my org notes"
    (interactive)
    (let ((consult-ripgrep-command "rg --null --ignore-case --type org --line-buffered --color=always --max-columns=500 --no-heading --line-number . -e ARG OPTS"))
      (consult-ripgrep org-directory)))

#+end_src
** Sudo Edit File

From : https://karthinks.com/software/fifteen-ways-to-use-embark/

#+begin_src emacs-lisp
      (defun nc/sudo-find-file (file)
        "Open FILE as root."
        (interactive "FOpen file as root: ")
        (when (file-writable-p file)
          (user-error "File is user writeable, aborting sudo"))
        (find-file (if (file-remote-p file)
                       (concat "/" (file-remote-p file 'method) ":"
                               (file-remote-p file 'user) "@" (file-remote-p file 'host)
                               "|sudo:root@"
                               (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                     (concat "/sudo:root@localhost:" file))))
#+end_src
** Getting Ready
Experimental get Ready
#+begin_src elisp
  (defun nc/getting-ready()
    "Getting Ready"
    (interactive)
    (toggle-frame-maximized)
    (split-window-vertically)
    (nc/goto-journal-file)
    (org-roam-node-random))
#+end_src

* Provided modules

** =setup-prefs= module
#+begin_src emacs-lisp :tangle ./lisp/setup-prefs.el
  (provide 'setup-prefs)
  ;;; setup-prefs.el ends here
#+end_src


** =setup-ui= module
#+begin_src emacs-lisp :tangle ./lisp/setup-ui.el
  (provide 'setup-ui)
  ;;; setup-ui.el ends here
#+end_src


** =setup-keys= module
#+begin_src emacs-lisp :tangle ./lisp/setup-keys.el
  (provide 'setup-keys)
  ;;; setup-keys.el ends here
#+end_src

** =setup-windows= module
#+begin_src emacs-lisp :tangle ./lisp/setup-windows.el
  (provide 'setup-windows)
  ;;; setup-windows.el ends here
#+end_src



** =setup-core= module
#+begin_src emacs-lisp :tangle ./lisp/setup-core.el
  (provide 'setup-core)
  ;;; setup-core.el ends here
#+end_src
** =setup-completion= module
#+begin_src emacs-lisp :tangle ./lisp/setup-completion.el
  (provide 'setup-completion)
  ;;; setup-completion.el ends here
#+end_src


** =setup-org= module
#+begin_src emacs-lisp :tangle ./lisp/setup-org.el
  (provide 'setup-org)
  ;;; setup-org.el ends here
#+end_src

** =nc-programming= module
#+begin_src emacs-lisp :tangle ./lisp/setup-programming.el
  (provide 'setup-programming)
  ;;; setup-programming.el ends here
#+end_src


** =setup-shell= module
#+begin_src emacs-lisp :tangle ./lisp/setup-shell.el
  (provide 'setup-shell)
  ;;; setup-shell.el ends here
#+end_src

** =setup-functions= module
#+begin_src emacs-lisp :tangle ./lisp/setup-functions.el
  (provide 'setup-functions)
  ;;; setup-functions.el ends here
#+end_src


# Local Variables:
# eval: (add-hook 'after-save-hook #'org-babel-tangle nil t)
# End:
